/*!
  * https://github.com/paulmillr/es6-shim
  * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
  *   and contributors,  MIT License
  * es6-shim: v0.35.1
  * see https://github.com/paulmillr/es6-shim/blob/0.35.1/LICENSE
  * Details and documentation:
  * https://github.com/paulmillr/es6-shim/
  */
(function(e,t){if(typeof define==="function"&&define.amd){define(t)}else if(typeof exports==="object"){module.exports=t()}else{e.returnExports=t()}})(this,function(){"use strict";var e=Function.call.bind(Function.apply);var t=Function.call.bind(Function.call);var r=Array.isArray;var n=Object.keys;var o=function notThunker(t){return function notThunk(){return!e(t,this,arguments)}};var i=function(e){try{e();return false}catch(t){return true}};var a=function valueOrFalseIfThrows(e){try{return e()}catch(t){return false}};var u=o(i);var f=function(){return!i(function(){Object.defineProperty({},"x",{get:function(){}})})};var s=!!Object.defineProperty&&f();var c=function foo(){}.name==="foo";var l=Function.call.bind(Array.prototype.forEach);var p=Function.call.bind(Array.prototype.reduce);var v=Function.call.bind(Array.prototype.filter);var y=Function.call.bind(Array.prototype.some);var h=function(e,t,r,n){if(!n&&t in e){return}if(s){Object.defineProperty(e,t,{configurable:true,enumerable:false,writable:true,value:r})}else{e[t]=r}};var b=function(e,t,r){l(n(t),function(n){var o=t[n];h(e,n,o,!!r)})};var g=Function.call.bind(Object.prototype.toString);var d=typeof/abc/==="function"?function IsCallableSlow(e){return typeof e==="function"&&g(e)==="[object Function]"}:function IsCallableFast(e){return typeof e==="function"};var O={getter:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}Object.defineProperty(e,t,{configurable:true,enumerable:false,get:r})},proxy:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,{configurable:n.configurable,enumerable:n.enumerable,get:function getKey(){return e[t]},set:function setKey(r){e[t]=r}})},redefine:function(e,t,r){if(s){var n=Object.getOwnPropertyDescriptor(e,t);n.value=r;Object.defineProperty(e,t,n)}else{e[t]=r}},defineByDescriptor:function(e,t,r){if(s){Object.defineProperty(e,t,r)}else if("value"in r){e[t]=r.value}},preserveToString:function(e,t){if(t&&d(t.toString)){h(e,"toString",t.toString.bind(t),true)}}};var m=Object.create||function(e,t){var r=function Prototype(){};r.prototype=e;var o=new r;if(typeof t!=="undefined"){n(t).forEach(function(e){O.defineByDescriptor(o,e,t[e])})}return o};var w=function(e,t){if(!Object.setPrototypeOf){return false}return a(function(){var r=function Subclass(t){var r=new e(t);Object.setPrototypeOf(r,Subclass.prototype);return r};Object.setPrototypeOf(r,e);r.prototype=m(e.prototype,{constructor:{value:r}});return t(r)})};var j=function(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")};var S=j();var T=S.isFinite;var I=Function.call.bind(String.prototype.indexOf);var E=Function.apply.bind(Array.prototype.indexOf);var P=Function.call.bind(Array.prototype.concat);var C=Function.call.bind(String.prototype.slice);var M=Function.call.bind(Array.prototype.push);var x=Function.apply.bind(Array.prototype.push);var N=Function.call.bind(Array.prototype.shift);var A=Math.max;var R=Math.min;var _=Math.floor;var k=Math.abs;var F=Math.exp;var L=Math.log;var D=Math.sqrt;var z=Function.call.bind(Object.prototype.hasOwnProperty);var q;var W=function(){};var G=S.Symbol||{};var H=G.species||"@@species";var V=Number.isNaN||function isNaN(e){return e!==e};var B=Number.isFinite||function isFinite(e){return typeof e==="number"&&T(e)};var $=d(Math.sign)?Math.sign:function sign(e){var t=Number(e);if(t===0){return t}if(V(t)){return t}return t<0?-1:1};var U=function isArguments(e){return g(e)==="[object Arguments]"};var J=function isArguments(e){return e!==null&&typeof e==="object"&&typeof e.length==="number"&&e.length>=0&&g(e)!=="[object Array]"&&g(e.callee)==="[object Function]"};var X=U(arguments)?U:J;var K={primitive:function(e){return e===null||typeof e!=="function"&&typeof e!=="object"},string:function(e){return g(e)==="[object String]"},regex:function(e){return g(e)==="[object RegExp]"},symbol:function(e){return typeof S.Symbol==="function"&&typeof e==="symbol"}};var Z=function overrideNative(e,t,r){var n=e[t];h(e,t,r,true);O.preserveToString(e[t],n)};var Y=typeof G==="function"&&typeof G["for"]==="function"&&K.symbol(G());var Q=K.symbol(G.iterator)?G.iterator:"_es6-shim iterator_";if(S.Set&&typeof(new S.Set)["@@iterator"]==="function"){Q="@@iterator"}if(!S.Reflect){h(S,"Reflect",{},true)}var ee=S.Reflect;var te=String;var re={Call:function Call(t,r){var n=arguments.length>2?arguments[2]:[];if(!re.IsCallable(t)){throw new TypeError(t+" is not a function")}return e(t,r,n)},RequireObjectCoercible:function(e,t){if(e==null){throw new TypeError(t||"Cannot call method on "+e)}return e},TypeIsObject:function(e){if(e===void 0||e===null||e===true||e===false){return false}return typeof e==="function"||typeof e==="object"},ToObject:function(e,t){return Object(re.RequireObjectCoercible(e,t))},IsCallable:d,IsConstructor:function(e){return re.IsCallable(e)},ToInt32:function(e){return re.ToNumber(e)>>0},ToUint32:function(e){return re.ToNumber(e)>>>0},ToNumber:function(e){if(g(e)==="[object Symbol]"){throw new TypeError("Cannot convert a Symbol value to a number")}return+e},ToInteger:function(e){var t=re.ToNumber(e);if(V(t)){return 0}if(t===0||!B(t)){return t}return(t>0?1:-1)*_(k(t))},ToLength:function(e){var t=re.ToInteger(e);if(t<=0){return 0}if(t>Number.MAX_SAFE_INTEGER){return Number.MAX_SAFE_INTEGER}return t},SameValue:function(e,t){if(e===t){if(e===0){return 1/e===1/t}return true}return V(e)&&V(t)},SameValueZero:function(e,t){return e===t||V(e)&&V(t)},IsIterable:function(e){return re.TypeIsObject(e)&&(typeof e[Q]!=="undefined"||X(e))},GetIterator:function(e){if(X(e)){return new q(e,"value")}var t=re.GetMethod(e,Q);if(!re.IsCallable(t)){throw new TypeError("value is not an iterable")}var r=re.Call(t,e);if(!re.TypeIsObject(r)){throw new TypeError("bad iterator")}return r},GetMethod:function(e,t){var r=re.ToObject(e)[t];if(r===void 0||r===null){return void 0}if(!re.IsCallable(r)){throw new TypeError("Method not callable: "+t)}return r},IteratorComplete:function(e){return!!e.done},IteratorClose:function(e,t){var r=re.GetMethod(e,"return");if(r===void 0){return}var n,o;try{n=re.Call(r,e)}catch(i){o=i}if(t){return}if(o){throw o}if(!re.TypeIsObject(n)){throw new TypeError("Iterator's return method returned a non-object.")}},IteratorNext:function(e){var t=arguments.length>1?e.next(arguments[1]):e.next();if(!re.TypeIsObject(t)){throw new TypeError("bad iterator")}return t},IteratorStep:function(e){var t=re.IteratorNext(e);var r=re.IteratorComplete(t);return r?false:t},Construct:function(e,t,r,n){var o=typeof r==="undefined"?e:r;if(!n&&ee.construct){return ee.construct(e,t,o)}var i=o.prototype;if(!re.TypeIsObject(i)){i=Object.prototype}var a=m(i);var u=re.Call(e,a,t);return re.TypeIsObject(u)?u:a},SpeciesConstructor:function(e,t){var r=e.constructor;if(r===void 0){return t}if(!re.TypeIsObject(r)){throw new TypeError("Bad constructor")}var n=r[H];if(n===void 0||n===null){return t}if(!re.IsConstructor(n)){throw new TypeError("Bad @@species")}return n},CreateHTML:function(e,t,r,n){var o=re.ToString(e);var i="<"+t;if(r!==""){var a=re.ToString(n);var u=a.replace(/"/g,"&quot;");i+=" "+r+'="'+u+'"'}var f=i+">";var s=f+o;return s+"</"+t+">"},IsRegExp:function IsRegExp(e){if(!re.TypeIsObject(e)){return false}var t=e[G.match];if(typeof t!=="undefined"){return!!t}return K.regex(e)},ToString:function ToString(e){return te(e)}};if(s&&Y){var ne=function defineWellKnownSymbol(e){if(K.symbol(G[e])){return G[e]}var t=G["for"]("Symbol."+e);Object.defineProperty(G,e,{configurable:false,enumerable:false,writable:false,value:t});return t};if(!K.symbol(G.search)){var oe=ne("search");var ie=String.prototype.search;h(RegExp.prototype,oe,function search(e){return re.Call(ie,e,[this])});var ae=function search(e){var t=re.RequireObjectCoercible(this);if(e!==null&&typeof e!=="undefined"){var r=re.GetMethod(e,oe);if(typeof r!=="undefined"){return re.Call(r,e,[t])}}return re.Call(ie,t,[re.ToString(e)])};Z(String.prototype,"search",ae)}if(!K.symbol(G.replace)){var ue=ne("replace");var fe=String.prototype.replace;h(RegExp.prototype,ue,function replace(e,t){return re.Call(fe,e,[this,t])});var se=function replace(e,t){var r=re.RequireObjectCoercible(this);if(e!==null&&typeof e!=="undefined"){var n=re.GetMethod(e,ue);if(typeof n!=="undefined"){return re.Call(n,e,[r,t])}}return re.Call(fe,r,[re.ToString(e),t])};Z(String.prototype,"replace",se)}if(!K.symbol(G.split)){var ce=ne("split");var le=String.prototype.split;h(RegExp.prototype,ce,function split(e,t){return re.Call(le,e,[this,t])});var pe=function split(e,t){var r=re.RequireObjectCoercible(this);if(e!==null&&typeof e!=="undefined"){var n=re.GetMethod(e,ce);if(typeof n!=="undefined"){return re.Call(n,e,[r,t])}}return re.Call(le,r,[re.ToString(e),t])};Z(String.prototype,"split",pe)}var ve=K.symbol(G.match);var ye=ve&&function(){var e={};e[G.match]=function(){return 42};return"a".match(e)!==42}();if(!ve||ye){var he=ne("match");var be=String.prototype.match;h(RegExp.prototype,he,function match(e){return re.Call(be,e,[this])});var ge=function match(e){var t=re.RequireObjectCoercible(this);if(e!==null&&typeof e!=="undefined"){var r=re.GetMethod(e,he);if(typeof r!=="undefined"){return re.Call(r,e,[t])}}return re.Call(be,t,[re.ToString(e)])};Z(String.prototype,"match",ge)}}var de=function wrapConstructor(e,t,r){O.preserveToString(t,e);if(Object.setPrototypeOf){Object.setPrototypeOf(e,t)}if(s){l(Object.getOwnPropertyNames(e),function(n){if(n in W||r[n]){return}O.proxy(e,n,t)})}else{l(Object.keys(e),function(n){if(n in W||r[n]){return}t[n]=e[n]})}t.prototype=e.prototype;O.redefine(e.prototype,"constructor",t)};var Oe=function(){return this};var me=function(e){if(s&&!z(e,H)){O.getter(e,H,Oe)}};var we=function(e,t){var r=t||function iterator(){return this};h(e,Q,r);if(!e[Q]&&K.symbol(Q)){e[Q]=r}};var je=function createDataProperty(e,t,r){if(s){Object.defineProperty(e,t,{configurable:true,enumerable:true,writable:true,value:r})}else{e[t]=r}};var Se=function createDataPropertyOrThrow(e,t,r){je(e,t,r);if(!re.SameValue(e[t],r)){throw new TypeError("property is nonconfigurable")}};var Te=function(e,t,r,n){if(!re.TypeIsObject(e)){throw new TypeError("Constructor requires `new`: "+t.name)}var o=t.prototype;if(!re.TypeIsObject(o)){o=r}var i=m(o);for(var a in n){if(z(n,a)){var u=n[a];h(i,a,u,true)}}return i};if(String.fromCodePoint&&String.fromCodePoint.length!==1){var Ie=String.fromCodePoint;Z(String,"fromCodePoint",function fromCodePoint(e){return re.Call(Ie,this,arguments)})}var Ee={fromCodePoint:function fromCodePoint(e){var t=[];var r;for(var n=0,o=arguments.length;n<o;n++){r=Number(arguments[n]);if(!re.SameValue(r,re.ToInteger(r))||r<0||r>1114111){throw new RangeError("Invalid code point "+r)}if(r<65536){M(t,String.fromCharCode(r))}else{r-=65536;M(t,String.fromCharCode((r>>10)+55296));M(t,String.fromCharCode(r%1024+56320))}}return t.join("")},raw:function raw(e){var t=re.ToObject(e,"bad callSite");var r=re.ToObject(t.raw,"bad raw value");var n=r.length;var o=re.ToLength(n);if(o<=0){return""}var i=[];var a=0;var u,f,s,c;while(a<o){u=re.ToString(a);s=re.ToString(r[u]);M(i,s);if(a+1>=o){break}f=a+1<arguments.length?arguments[a+1]:"";c=re.ToString(f);M(i,c);a+=1}return i.join("")}};if(String.raw&&String.raw({raw:{0:"x",1:"y",length:2}})!=="xy"){Z(String,"raw",Ee.raw)}b(String,Ee);var Pe=function repeat(e,t){if(t<1){return""}if(t%2){return repeat(e,t-1)+e}var r=repeat(e,t/2);return r+r};var Ce=Infinity;var Me={repeat:function repeat(e){var t=re.ToString(re.RequireObjectCoercible(this));var r=re.ToInteger(e);if(r<0||r>=Ce){throw new RangeError("repeat count must be less than infinity and not overflow maximum string size")}return Pe(t,r)},startsWith:function startsWith(e){var t=re.ToString(re.RequireObjectCoercible(this));if(re.IsRegExp(e)){throw new TypeError('Cannot call method "startsWith" with a regex')}var r=re.ToString(e);var n;if(arguments.length>1){n=arguments[1]}var o=A(re.ToInteger(n),0);return C(t,o,o+r.length)===r},endsWith:function endsWith(e){var t=re.ToString(re.RequireObjectCoercible(this));if(re.IsRegExp(e)){throw new TypeError('Cannot call method "endsWith" with a regex')}var r=re.ToString(e);var n=t.length;var o;if(arguments.length>1){o=arguments[1]}var i=typeof o==="undefined"?n:re.ToInteger(o);var a=R(A(i,0),n);return C(t,a-r.length,a)===r},includes:function includes(e){if(re.IsRegExp(e)){throw new TypeError('"includes" does not accept a RegExp')}var t=re.ToString(e);var r;if(arguments.length>1){r=arguments[1]}return I(this,t,r)!==-1},codePointAt:function codePointAt(e){var t=re.ToString(re.RequireObjectCoercible(this));var r=re.ToInteger(e);var n=t.length;if(r>=0&&r<n){var o=t.charCodeAt(r);var i=r+1===n;if(o<55296||o>56319||i){return o}var a=t.charCodeAt(r+1);if(a<56320||a>57343){return o}return(o-55296)*1024+(a-56320)+65536}}};if(String.prototype.includes&&"a".includes("a",Infinity)!==false){Z(String.prototype,"includes",Me.includes)}if(String.prototype.startsWith&&String.prototype.endsWith){var xe=i(function(){"/a/".startsWith(/a/)});var Ne=a(function(){return"abc".startsWith("a",Infinity)===false});if(!xe||!Ne){Z(String.prototype,"startsWith",Me.startsWith);Z(String.prototype,"endsWith",Me.endsWith)}}if(Y){var Ae=a(function(){var e=/a/;e[G.match]=false;return"/a/".startsWith(e)});if(!Ae){Z(String.prototype,"startsWith",Me.startsWith)}var Re=a(function(){var e=/a/;e[G.match]=false;return"/a/".endsWith(e)});if(!Re){Z(String.prototype,"endsWith",Me.endsWith)}var _e=a(function(){var e=/a/;e[G.match]=false;return"/a/".includes(e)});if(!_e){Z(String.prototype,"includes",Me.includes)}}b(String.prototype,Me);var ke=["	\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003","\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028","\u2029\ufeff"].join("");var Fe=new RegExp("(^["+ke+"]+)|(["+ke+"]+$)","g");var Le=function trim(){return re.ToString(re.RequireObjectCoercible(this)).replace(Fe,"")};var De=["\x85","\u200b","\ufffe"].join("");var ze=new RegExp("["+De+"]","g");var qe=/^[\-+]0x[0-9a-f]+$/i;var We=De.trim().length!==De.length;h(String.prototype,"trim",Le,We);var Ge=function(e){return{value:e,done:arguments.length===0}};var He=function(e){re.RequireObjectCoercible(e);this._s=re.ToString(e);this._i=0};He.prototype.next=function(){var e=this._s;var t=this._i;if(typeof e==="undefined"||t>=e.length){this._s=void 0;return Ge()}var r=e.charCodeAt(t);var n,o;if(r<55296||r>56319||t+1===e.length){o=1}else{n=e.charCodeAt(t+1);o=n<56320||n>57343?1:2}this._i=t+o;return Ge(e.substr(t,o))};we(He.prototype);we(String.prototype,function(){return new He(this)});var Ve={from:function from(e){var r=this;var n;if(arguments.length>1){n=arguments[1]}var o,i;if(typeof n==="undefined"){o=false}else{if(!re.IsCallable(n)){throw new TypeError("Array.from: when provided, the second argument must be a function")}if(arguments.length>2){i=arguments[2]}o=true}var a=typeof(X(e)||re.GetMethod(e,Q))!=="undefined";var u,f,s;if(a){f=re.IsConstructor(r)?Object(new r):[];var c=re.GetIterator(e);var l,p;s=0;while(true){l=re.IteratorStep(c);if(l===false){break}p=l.value;try{if(o){p=typeof i==="undefined"?n(p,s):t(n,i,p,s)}f[s]=p}catch(v){re.IteratorClose(c,true);throw v}s+=1}u=s}else{var y=re.ToObject(e);u=re.ToLength(y.length);f=re.IsConstructor(r)?Object(new r(u)):new Array(u);var h;for(s=0;s<u;++s){h=y[s];if(o){h=typeof i==="undefined"?n(h,s):t(n,i,h,s)}Se(f,s,h)}}f.length=u;return f},of:function of(){var e=arguments.length;var t=this;var n=r(t)||!re.IsCallable(t)?new Array(e):re.Construct(t,[e]);for(var o=0;o<e;++o){Se(n,o,arguments[o])}n.length=e;return n}};b(Array,Ve);me(Array);q=function(e,t){this.i=0;this.array=e;this.kind=t};b(q.prototype,{next:function(){var e=this.i;var t=this.array;if(!(this instanceof q)){throw new TypeError("Not an ArrayIterator")}if(typeof t!=="undefined"){var r=re.ToLength(t.length);for(;e<r;e++){var n=this.kind;var o;if(n==="key"){o=e}else if(n==="value"){o=t[e]}else if(n==="entry"){o=[e,t[e]]}this.i=e+1;return Ge(o)}}this.array=void 0;return Ge()}});we(q.prototype);var Be=Array.of===Ve.of||function(){var e=function Foo(e){this.length=e};e.prototype=[];var t=Array.of.apply(e,[1,2]);return t instanceof e&&t.length===2}();if(!Be){Z(Array,"of",Ve.of)}var $e={copyWithin:function copyWithin(e,t){var r=re.ToObject(this);var n=re.ToLength(r.length);var o=re.ToInteger(e);var i=re.ToInteger(t);var a=o<0?A(n+o,0):R(o,n);var u=i<0?A(n+i,0):R(i,n);var f;if(arguments.length>2){f=arguments[2]}var s=typeof f==="undefined"?n:re.ToInteger(f);var c=s<0?A(n+s,0):R(s,n);var l=R(c-u,n-a);var p=1;if(u<a&&a<u+l){p=-1;u+=l-1;a+=l-1}while(l>0){if(u in r){r[a]=r[u]}else{delete r[a]}u+=p;a+=p;l-=1}return r},fill:function fill(e){var t;if(arguments.length>1){t=arguments[1]}var r;if(arguments.length>2){r=arguments[2]}var n=re.ToObject(this);var o=re.ToLength(n.length);t=re.ToInteger(typeof t==="undefined"?0:t);r=re.ToInteger(typeof r==="undefined"?o:r);var i=t<0?A(o+t,0):R(t,o);var a=r<0?o+r:r;for(var u=i;u<o&&u<a;++u){n[u]=e}return n},find:function find(e){var r=re.ToObject(this);var n=re.ToLength(r.length);if(!re.IsCallable(e)){throw new TypeError("Array#find: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0,a;i<n;i++){a=r[i];if(o){if(t(e,o,a,i,r)){return a}}else if(e(a,i,r)){return a}}},findIndex:function findIndex(e){var r=re.ToObject(this);var n=re.ToLength(r.length);if(!re.IsCallable(e)){throw new TypeError("Array#findIndex: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0;i<n;i++){if(o){if(t(e,o,r[i],i,r)){return i}}else if(e(r[i],i,r)){return i}}return-1},keys:function keys(){return new q(this,"key")},values:function values(){return new q(this,"value")},entries:function entries(){return new q(this,"entry")}};if(Array.prototype.keys&&!re.IsCallable([1].keys().next)){delete Array.prototype.keys}if(Array.prototype.entries&&!re.IsCallable([1].entries().next)){delete Array.prototype.entries}if(Array.prototype.keys&&Array.prototype.entries&&!Array.prototype.values&&Array.prototype[Q]){b(Array.prototype,{values:Array.prototype[Q]});if(K.symbol(G.unscopables)){Array.prototype[G.unscopables].values=true}}if(c&&Array.prototype.values&&Array.prototype.values.name!=="values"){var Ue=Array.prototype.values;Z(Array.prototype,"values",function values(){return re.Call(Ue,this,arguments)});h(Array.prototype,Q,Array.prototype.values,true)}b(Array.prototype,$e);if(1/[true].indexOf(true,-0)<0){h(Array.prototype,"indexOf",function indexOf(e){var t=E(this,arguments);if(t===0&&1/t<0){return 0}return t},true)}we(Array.prototype,function(){return this.values()});if(Object.getPrototypeOf){we(Object.getPrototypeOf([].values()))}var Je=function(){return a(function(){return Array.from({length:-1}).length===0})}();var Xe=function(){var e=Array.from([0].entries());return e.length===1&&r(e[0])&&e[0][0]===0&&e[0][1]===0}();if(!Je||!Xe){Z(Array,"from",Ve.from)}var Ke=function(){return a(function(){return Array.from([0],void 0)})}();if(!Ke){var Ze=Array.from;Z(Array,"from",function from(e){if(arguments.length>1&&typeof arguments[1]!=="undefined"){return re.Call(Ze,this,arguments)}else{return t(Ze,this,e)}})}var Ye=-(Math.pow(2,32)-1);var Qe=function(e,r){var n={length:Ye};n[r?(n.length>>>0)-1:0]=true;return a(function(){t(e,n,function(){throw new RangeError("should not reach here")},[]);return true})};if(!Qe(Array.prototype.forEach)){var et=Array.prototype.forEach;Z(Array.prototype,"forEach",function forEach(e){return re.Call(et,this.length>=0?this:[],arguments)},true)}if(!Qe(Array.prototype.map)){var tt=Array.prototype.map;Z(Array.prototype,"map",function map(e){return re.Call(tt,this.length>=0?this:[],arguments)},true)}if(!Qe(Array.prototype.filter)){var rt=Array.prototype.filter;Z(Array.prototype,"filter",function filter(e){return re.Call(rt,this.length>=0?this:[],arguments)},true)}if(!Qe(Array.prototype.some)){var nt=Array.prototype.some;Z(Array.prototype,"some",function some(e){return re.Call(nt,this.length>=0?this:[],arguments)},true)}if(!Qe(Array.prototype.every)){var ot=Array.prototype.every;Z(Array.prototype,"every",function every(e){return re.Call(ot,this.length>=0?this:[],arguments)},true)}if(!Qe(Array.prototype.reduce)){var it=Array.prototype.reduce;Z(Array.prototype,"reduce",function reduce(e){return re.Call(it,this.length>=0?this:[],arguments)},true)}if(!Qe(Array.prototype.reduceRight,true)){var at=Array.prototype.reduceRight;Z(Array.prototype,"reduceRight",function reduceRight(e){return re.Call(at,this.length>=0?this:[],arguments)},true)}var ut=Number("0o10")!==8;var ft=Number("0b10")!==2;var st=y(De,function(e){return Number(e+0+e)===0});if(ut||ft||st){var ct=Number;var lt=/^0b[01]+$/i;var pt=/^0o[0-7]+$/i;var vt=lt.test.bind(lt);var yt=pt.test.bind(pt);var ht=function(e){var t;if(typeof e.valueOf==="function"){t=e.valueOf();if(K.primitive(t)){return t}}if(typeof e.toString==="function"){t=e.toString();if(K.primitive(t)){return t}}throw new TypeError("No default value")};var bt=ze.test.bind(ze);var gt=qe.test.bind(qe);var dt=function(){var e=function Number(t){var r;if(arguments.length>0){r=K.primitive(t)?t:ht(t,"number")}else{r=0}if(typeof r==="string"){r=re.Call(Le,r);if(vt(r)){r=parseInt(C(r,2),2)}else if(yt(r)){r=parseInt(C(r,2),8)}else if(bt(r)||gt(r)){r=NaN}}var n=this;var o=a(function(){ct.prototype.valueOf.call(n);return true});if(n instanceof e&&!o){return new ct(r)}return ct(r)};return e}();de(ct,dt,{});b(dt,{NaN:ct.NaN,MAX_VALUE:ct.MAX_VALUE,MIN_VALUE:ct.MIN_VALUE,NEGATIVE_INFINITY:ct.NEGATIVE_INFINITY,POSITIVE_INFINITY:ct.POSITIVE_INFINITY});Number=dt;O.redefine(S,"Number",dt)}var Ot=Math.pow(2,53)-1;b(Number,{MAX_SAFE_INTEGER:Ot,MIN_SAFE_INTEGER:-Ot,EPSILON:2.220446049250313e-16,parseInt:S.parseInt,parseFloat:S.parseFloat,isFinite:B,isInteger:function isInteger(e){return B(e)&&re.ToInteger(e)===e},isSafeInteger:function isSafeInteger(e){return Number.isInteger(e)&&k(e)<=Number.MAX_SAFE_INTEGER},isNaN:V});h(Number,"parseInt",S.parseInt,Number.parseInt!==S.parseInt);if(![,1].find(function(e,t){return t===0})){Z(Array.prototype,"find",$e.find)}if([,1].findIndex(function(e,t){return t===0})!==0){Z(Array.prototype,"findIndex",$e.findIndex)}var mt=Function.bind.call(Function.bind,Object.prototype.propertyIsEnumerable);var wt=function ensureEnumerable(e,t){if(s&&mt(e,t)){Object.defineProperty(e,t,{enumerable:false})}};var jt=function sliceArgs(){var e=Number(this);var t=arguments.length;var r=t-e;var n=new Array(r<0?0:r);for(var o=e;o<t;++o){n[o-e]=arguments[o]}return n};var St=function assignTo(e){return function assignToSource(t,r){t[r]=e[r];return t}};var Tt=function(e,t){var r=n(Object(t));var o;if(re.IsCallable(Object.getOwnPropertySymbols)){o=v(Object.getOwnPropertySymbols(Object(t)),mt(t))}return p(P(r,o||[]),St(t),e)};var It={assign:function(e,t){var r=re.ToObject(e,"Cannot convert undefined or null to object");return p(re.Call(jt,1,arguments),Tt,r)},is:function is(e,t){return re.SameValue(e,t)}};var Et=Object.assign&&Object.preventExtensions&&function(){var e=Object.preventExtensions({1:2});try{Object.assign(e,"xy")}catch(t){return e[1]==="y"}}();if(Et){Z(Object,"assign",It.assign)}b(Object,It);if(s){var Pt={setPrototypeOf:function(e,r){var n;var o=function(e,t){if(!re.TypeIsObject(e)){throw new TypeError("cannot set prototype on a non-object")}if(!(t===null||re.TypeIsObject(t))){throw new TypeError("can only set prototype to an object or null"+t)}};var i=function(e,r){o(e,r);t(n,e,r);return e};try{n=e.getOwnPropertyDescriptor(e.prototype,r).set;t(n,{},null)}catch(a){if(e.prototype!=={}[r]){return}n=function(e){this[r]=e};i.polyfill=i(i({},null),e.prototype)instanceof e}return i}(Object,"__proto__")};b(Object,Pt)}if(Object.setPrototypeOf&&Object.getPrototypeOf&&Object.getPrototypeOf(Object.setPrototypeOf({},null))!==null&&Object.getPrototypeOf(Object.create(null))===null){(function(){var e=Object.create(null);var t=Object.getPrototypeOf;var r=Object.setPrototypeOf;Object.getPrototypeOf=function(r){var n=t(r);return n===e?null:n};Object.setPrototypeOf=function(t,n){var o=n===null?e:n;return r(t,o)};Object.setPrototypeOf.polyfill=false})()}var Ct=!i(function(){Object.keys("foo")});if(!Ct){var Mt=Object.keys;Z(Object,"keys",function keys(e){return Mt(re.ToObject(e))});n=Object.keys}var xt=i(function(){Object.keys(/a/g)});if(xt){var Nt=Object.keys;Z(Object,"keys",function keys(e){if(K.regex(e)){var t=[];for(var r in e){if(z(e,r)){M(t,r)}}return t}return Nt(e)});n=Object.keys}if(Object.getOwnPropertyNames){var At=!i(function(){Object.getOwnPropertyNames("foo")});if(!At){var Rt=typeof window==="object"?Object.getOwnPropertyNames(window):[];var _t=Object.getOwnPropertyNames;Z(Object,"getOwnPropertyNames",function getOwnPropertyNames(e){var t=re.ToObject(e);if(g(t)==="[object Window]"){try{return _t(t)}catch(r){return P([],Rt)}}return _t(t)})}}if(Object.getOwnPropertyDescriptor){var kt=!i(function(){Object.getOwnPropertyDescriptor("foo","bar")});if(!kt){var Ft=Object.getOwnPropertyDescriptor;Z(Object,"getOwnPropertyDescriptor",function getOwnPropertyDescriptor(e,t){return Ft(re.ToObject(e),t)})}}if(Object.seal){var Lt=!i(function(){Object.seal("foo")});if(!Lt){var Dt=Object.seal;Z(Object,"seal",function seal(e){if(!re.TypeIsObject(e)){return e}return Dt(e)})}}if(Object.isSealed){var zt=!i(function(){Object.isSealed("foo")});if(!zt){var qt=Object.isSealed;Z(Object,"isSealed",function isSealed(e){if(!re.TypeIsObject(e)){return true}return qt(e)})}}if(Object.freeze){var Wt=!i(function(){Object.freeze("foo")});if(!Wt){var Gt=Object.freeze;Z(Object,"freeze",function freeze(e){if(!re.TypeIsObject(e)){return e}return Gt(e)})}}if(Object.isFrozen){var Ht=!i(function(){Object.isFrozen("foo")});if(!Ht){var Vt=Object.isFrozen;Z(Object,"isFrozen",function isFrozen(e){if(!re.TypeIsObject(e)){return true}return Vt(e)})}}if(Object.preventExtensions){var Bt=!i(function(){Object.preventExtensions("foo")});if(!Bt){var $t=Object.preventExtensions;Z(Object,"preventExtensions",function preventExtensions(e){if(!re.TypeIsObject(e)){return e}return $t(e)})}}if(Object.isExtensible){var Ut=!i(function(){Object.isExtensible("foo")});if(!Ut){var Jt=Object.isExtensible;Z(Object,"isExtensible",function isExtensible(e){if(!re.TypeIsObject(e)){return false}return Jt(e)})}}if(Object.getPrototypeOf){var Xt=!i(function(){Object.getPrototypeOf("foo")});if(!Xt){var Kt=Object.getPrototypeOf;Z(Object,"getPrototypeOf",function getPrototypeOf(e){return Kt(re.ToObject(e))})}}var Zt=s&&function(){var e=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags");return e&&re.IsCallable(e.get)}();if(s&&!Zt){var Yt=function flags(){if(!re.TypeIsObject(this)){throw new TypeError("Method called on incompatible type: must be an object.")}var e="";if(this.global){e+="g"}if(this.ignoreCase){e+="i"}if(this.multiline){e+="m"}if(this.unicode){e+="u"}if(this.sticky){e+="y"}return e};O.getter(RegExp.prototype,"flags",Yt)}var Qt=s&&a(function(){return String(new RegExp(/a/g,"i"))==="/a/i"});var er=Y&&s&&function(){var e=/./;e[G.match]=false;return RegExp(e)===e}();var tr=a(function(){return RegExp.prototype.toString.call({source:"abc"})==="/abc/"});var rr=tr&&a(function(){return RegExp.prototype.toString.call({source:"a",flags:"b"})==="/a/b"});if(!tr||!rr){var nr=RegExp.prototype.toString;h(RegExp.prototype,"toString",function toString(){var e=re.RequireObjectCoercible(this);if(K.regex(e)){return t(nr,e)}var r=te(e.source);var n=te(e.flags);return"/"+r+"/"+n},true);O.preserveToString(RegExp.prototype.toString,nr)}if(s&&(!Qt||er)){var or=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags").get;var ir=Object.getOwnPropertyDescriptor(RegExp.prototype,"source")||{};var ar=function(){return this.source};var ur=re.IsCallable(ir.get)?ir.get:ar;var fr=RegExp;var sr=function(){return function RegExp(e,t){var r=re.IsRegExp(e);var n=this instanceof RegExp;if(!n&&r&&typeof t==="undefined"&&e.constructor===RegExp){return e}var o=e;var i=t;if(K.regex(e)){o=re.Call(ur,e);i=typeof t==="undefined"?re.Call(or,e):t;return new RegExp(o,i)}else if(r){o=e.source;i=typeof t==="undefined"?e.flags:t}return new fr(e,t)}}();de(fr,sr,{$input:true});RegExp=sr;O.redefine(S,"RegExp",sr)}if(s){var cr={input:"$_",lastMatch:"$&",lastParen:"$+",leftContext:"$`",rightContext:"$'"};l(n(cr),function(e){if(e in RegExp&&!(cr[e]in RegExp)){O.getter(RegExp,cr[e],function get(){return RegExp[e]})}})}me(RegExp);var lr=1/Number.EPSILON;var pr=function roundTiesToEven(e){return e+lr-lr};var vr=Math.pow(2,-23);var yr=Math.pow(2,127)*(2-vr);var hr=Math.pow(2,-126);var br=Math.E;var gr=Math.LOG2E;var dr=Math.LOG10E;var Or=Number.prototype.clz;delete Number.prototype.clz;var mr={acosh:function acosh(e){var t=Number(e);if(V(t)||e<1){return NaN}if(t===1){return 0}if(t===Infinity){return t}return L(t/br+D(t+1)*D(t-1)/br)+1},asinh:function asinh(e){var t=Number(e);if(t===0||!T(t)){return t}return t<0?-asinh(-t):L(t+D(t*t+1))},atanh:function atanh(e){var t=Number(e);if(V(t)||t<-1||t>1){return NaN}if(t===-1){return-Infinity}if(t===1){return Infinity}if(t===0){return t}return.5*L((1+t)/(1-t))},cbrt:function cbrt(e){var t=Number(e);if(t===0){return t}var r=t<0;var n;if(r){t=-t}if(t===Infinity){n=Infinity}else{n=F(L(t)/3);n=(t/(n*n)+2*n)/3}return r?-n:n},clz32:function clz32(e){var t=Number(e);var r=re.ToUint32(t);if(r===0){return 32}return Or?re.Call(Or,r):31-_(L(r+.5)*gr)},cosh:function cosh(e){var t=Number(e);if(t===0){return 1}if(V(t)){return NaN}if(!T(t)){return Infinity}if(t<0){t=-t}if(t>21){return F(t)/2}return(F(t)+F(-t))/2},expm1:function expm1(e){var t=Number(e);if(t===-Infinity){return-1}if(!T(t)||t===0){return t}if(k(t)>.5){return F(t)-1}var r=t;var n=0;var o=1;while(n+r!==n){n+=r;o+=1;r*=t/o}return n},hypot:function hypot(e,t){var r=0;var n=0;for(var o=0;o<arguments.length;++o){var i=k(Number(arguments[o]));if(n<i){r*=n/i*(n/i);r+=1;n=i}else{r+=i>0?i/n*(i/n):i}}return n===Infinity?Infinity:n*D(r)},log2:function log2(e){return L(e)*gr},log10:function log10(e){return L(e)*dr},log1p:function log1p(e){var t=Number(e);if(t<-1||V(t)){return NaN}if(t===0||t===Infinity){return t}if(t===-1){return-Infinity}return 1+t-1===0?t:t*(L(1+t)/(1+t-1))},sign:$,sinh:function sinh(e){var t=Number(e);if(!T(t)||t===0){return t}if(k(t)<1){return(Math.expm1(t)-Math.expm1(-t))/2}return(F(t-1)-F(-t-1))*br/2},tanh:function tanh(e){var t=Number(e);if(V(t)||t===0){return t}if(t>=20){return 1}if(t<=-20){return-1}return(Math.expm1(t)-Math.expm1(-t))/(F(t)+F(-t))},trunc:function trunc(e){var t=Number(e);return t<0?-_(-t):_(t)},imul:function imul(e,t){var r=re.ToUint32(e);var n=re.ToUint32(t);var o=r>>>16&65535;var i=r&65535;var a=n>>>16&65535;var u=n&65535;return i*u+(o*u+i*a<<16>>>0)|0},fround:function fround(e){var t=Number(e);if(t===0||t===Infinity||t===-Infinity||V(t)){return t}var r=$(t);var n=k(t);if(n<hr){return r*pr(n/hr/vr)*hr*vr}var o=(1+vr/Number.EPSILON)*n;var i=o-(o-n);if(i>yr||V(i)){return r*Infinity}return r*i}};b(Math,mr);h(Math,"log1p",mr.log1p,Math.log1p(-1e-17)!==-1e-17);h(Math,"asinh",mr.asinh,Math.asinh(-1e7)!==-Math.asinh(1e7));h(Math,"tanh",mr.tanh,Math.tanh(-2e-17)!==-2e-17);h(Math,"acosh",mr.acosh,Math.acosh(Number.MAX_VALUE)===Infinity);h(Math,"cbrt",mr.cbrt,Math.abs(1-Math.cbrt(1e-300)/1e-100)/Number.EPSILON>8);h(Math,"sinh",mr.sinh,Math.sinh(-2e-17)!==-2e-17);var wr=Math.expm1(10);h(Math,"expm1",mr.expm1,wr>22025.465794806718||wr<22025.465794806718);var jr=Math.round;var Sr=Math.round(.5-Number.EPSILON/4)===0&&Math.round(-.5+Number.EPSILON/3.99)===1;var Tr=lr+1;var Ir=2*lr-1;var Er=[Tr,Ir].every(function(e){return Math.round(e)===e});h(Math,"round",function round(e){var t=_(e);var r=t===-1?-0:t+1;return e-t<.5?t:r},!Sr||!Er);O.preserveToString(Math.round,jr);var Pr=Math.imul;if(Math.imul(4294967295,5)!==-5){Math.imul=mr.imul;O.preserveToString(Math.imul,Pr)}if(Math.imul.length!==2){Z(Math,"imul",function imul(e,t){return re.Call(Pr,Math,arguments);
})}var Cr=function(){var e=S.setTimeout;if(typeof e!=="function"&&typeof e!=="object"){return}re.IsPromise=function(e){if(!re.TypeIsObject(e)){return false}if(typeof e._promise==="undefined"){return false}return true};var r=function(e){if(!re.IsConstructor(e)){throw new TypeError("Bad promise constructor")}var t=this;var r=function(e,r){if(t.resolve!==void 0||t.reject!==void 0){throw new TypeError("Bad Promise implementation!")}t.resolve=e;t.reject=r};t.resolve=void 0;t.reject=void 0;t.promise=new e(r);if(!(re.IsCallable(t.resolve)&&re.IsCallable(t.reject))){throw new TypeError("Bad promise constructor")}};var n;if(typeof window!=="undefined"&&re.IsCallable(window.postMessage)){n=function(){var e=[];var t="zero-timeout-message";var r=function(r){M(e,r);window.postMessage(t,"*")};var n=function(r){if(r.source===window&&r.data===t){r.stopPropagation();if(e.length===0){return}var n=N(e);n()}};window.addEventListener("message",n,true);return r}}var o=function(){var e=S.Promise;var t=e&&e.resolve&&e.resolve();return t&&function(e){return t.then(e)}};var i=re.IsCallable(S.setImmediate)?S.setImmediate:typeof process==="object"&&process.nextTick?process.nextTick:o()||(re.IsCallable(n)?n():function(t){e(t,0)});var a=function(e){return e};var u=function(e){throw e};var f=0;var s=1;var c=2;var l=0;var p=1;var v=2;var y={};var h=function(e,t,r){i(function(){g(e,t,r)})};var g=function(e,t,r){var n,o;if(t===y){return e(r)}try{n=e(r);o=t.resolve}catch(i){n=i;o=t.reject}o(n)};var d=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.fulfillReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+l],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=s;r.reactionLength=0};var O=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.rejectReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+p],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=c;r.reactionLength=0};var m=function(e){var t=false;var r=function(r){var n;if(t){return}t=true;if(r===e){return O(e,new TypeError("Self resolution"))}if(!re.TypeIsObject(r)){return d(e,r)}try{n=r.then}catch(o){return O(e,o)}if(!re.IsCallable(n)){return d(e,r)}i(function(){j(e,r,n)})};var n=function(r){if(t){return}t=true;return O(e,r)};return{resolve:r,reject:n}};var w=function(e,r,n,o){if(e===I){t(e,r,n,o,y)}else{t(e,r,n,o)}};var j=function(e,t,r){var n=m(e);var o=n.resolve;var i=n.reject;try{w(r,t,o,i)}catch(a){i(a)}};var T,I;var E=function(){var e=function Promise(t){if(!(this instanceof e)){throw new TypeError('Constructor Promise requires "new"')}if(this&&this._promise){throw new TypeError("Bad construction")}if(!re.IsCallable(t)){throw new TypeError("not a valid resolver")}var r=Te(this,e,T,{_promise:{result:void 0,state:f,reactionLength:0,fulfillReactionHandler0:void 0,rejectReactionHandler0:void 0,reactionCapability0:void 0}});var n=m(r);var o=n.reject;try{t(n.resolve,o)}catch(i){o(i)}return r};return e}();T=E.prototype;var P=function(e,t,r,n){var o=false;return function(i){if(o){return}o=true;t[e]=i;if(--n.count===0){var a=r.resolve;a(t)}}};var C=function(e,t,r){var n=e.iterator;var o=[];var i={count:1};var a,u;var f=0;while(true){try{a=re.IteratorStep(n);if(a===false){e.done=true;break}u=a.value}catch(s){e.done=true;throw s}o[f]=void 0;var c=t.resolve(u);var l=P(f,o,r,i);i.count+=1;w(c.then,c,l,r.reject);f+=1}if(--i.count===0){var p=r.resolve;p(o)}return r.promise};var x=function(e,t,r){var n=e.iterator;var o,i,a;while(true){try{o=re.IteratorStep(n);if(o===false){e.done=true;break}i=o.value}catch(u){e.done=true;throw u}a=t.resolve(i);w(a.then,a,r.resolve,r.reject)}return r.promise};b(E,{all:function all(e){var t=this;if(!re.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=re.GetIterator(e);i={iterator:o,done:false};return C(i,t,n)}catch(a){var u=a;if(i&&!i.done){try{re.IteratorClose(o,true)}catch(f){u=f}}var s=n.reject;s(u);return n.promise}},race:function race(e){var t=this;if(!re.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=re.GetIterator(e);i={iterator:o,done:false};return x(i,t,n)}catch(a){var u=a;if(i&&!i.done){try{re.IteratorClose(o,true)}catch(f){u=f}}var s=n.reject;s(u);return n.promise}},reject:function reject(e){var t=this;if(!re.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}var n=new r(t);var o=n.reject;o(e);return n.promise},resolve:function resolve(e){var t=this;if(!re.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}if(re.IsPromise(e)){var n=e.constructor;if(n===t){return e}}var o=new r(t);var i=o.resolve;i(e);return o.promise}});b(T,{"catch":function(e){return this.then(null,e)},then:function then(e,t){var n=this;if(!re.IsPromise(n)){throw new TypeError("not a promise")}var o=re.SpeciesConstructor(n,E);var i;var b=arguments.length>2&&arguments[2]===y;if(b&&o===E){i=y}else{i=new r(o)}var g=re.IsCallable(e)?e:a;var d=re.IsCallable(t)?t:u;var O=n._promise;var m;if(O.state===f){if(O.reactionLength===0){O.fulfillReactionHandler0=g;O.rejectReactionHandler0=d;O.reactionCapability0=i}else{var w=3*(O.reactionLength-1);O[w+l]=g;O[w+p]=d;O[w+v]=i}O.reactionLength+=1}else if(O.state===s){m=O.result;h(g,i,m)}else if(O.state===c){m=O.result;h(d,i,m)}else{throw new TypeError("unexpected Promise state")}return i.promise}});y=new r(E);I=T.then;return E}();if(S.Promise){delete S.Promise.accept;delete S.Promise.defer;delete S.Promise.prototype.chain}if(typeof Cr==="function"){b(S,{Promise:Cr});var Mr=w(S.Promise,function(e){return e.resolve(42).then(function(){})instanceof e});var xr=!i(function(){S.Promise.reject(42).then(null,5).then(null,W)});var Nr=i(function(){S.Promise.call(3,W)});var Ar=function(e){var t=e.resolve(5);t.constructor={};var r=e.resolve(t);try{r.then(null,W).then(null,W)}catch(n){return true}return t===r}(S.Promise);var Rr=s&&function(){var e=0;var t=Object.defineProperty({},"then",{get:function(){e+=1}});Promise.resolve(t);return e===1}();var _r=function BadResolverPromise(e){var t=new Promise(e);e(3,function(){});this.then=t.then;this.constructor=BadResolverPromise};_r.prototype=Promise.prototype;_r.all=Promise.all;var kr=a(function(){return!!_r.all([1,2])});if(!Mr||!xr||!Nr||Ar||!Rr||kr){Promise=Cr;Z(S,"Promise",Cr)}if(Promise.all.length!==1){var Fr=Promise.all;Z(Promise,"all",function all(e){return re.Call(Fr,this,arguments)})}if(Promise.race.length!==1){var Lr=Promise.race;Z(Promise,"race",function race(e){return re.Call(Lr,this,arguments)})}if(Promise.resolve.length!==1){var Dr=Promise.resolve;Z(Promise,"resolve",function resolve(e){return re.Call(Dr,this,arguments)})}if(Promise.reject.length!==1){var zr=Promise.reject;Z(Promise,"reject",function reject(e){return re.Call(zr,this,arguments)})}wt(Promise,"all");wt(Promise,"race");wt(Promise,"resolve");wt(Promise,"reject");me(Promise)}var qr=function(e){var t=n(p(e,function(e,t){e[t]=true;return e},{}));return e.join(":")===t.join(":")};var Wr=qr(["z","a","bb"]);var Gr=qr(["z",1,"a","3",2]);if(s){var Hr=function fastkey(e){if(!Wr){return null}if(typeof e==="undefined"||e===null){return"^"+re.ToString(e)}else if(typeof e==="string"){return"$"+e}else if(typeof e==="number"){if(!Gr){return"n"+e}return e}else if(typeof e==="boolean"){return"b"+e}return null};var Vr=function emptyObject(){return Object.create?Object.create(null):{}};var Br=function addIterableToMap(e,n,o){if(r(o)||K.string(o)){l(o,function(e){if(!re.TypeIsObject(e)){throw new TypeError("Iterator value "+e+" is not an entry object")}n.set(e[0],e[1])})}else if(o instanceof e){t(e.prototype.forEach,o,function(e,t){n.set(t,e)})}else{var i,a;if(o!==null&&typeof o!=="undefined"){a=n.set;if(!re.IsCallable(a)){throw new TypeError("bad map")}i=re.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=re.IteratorStep(i);if(u===false){break}var f=u.value;try{if(!re.TypeIsObject(f)){throw new TypeError("Iterator value "+f+" is not an entry object")}t(a,n,f[0],f[1])}catch(s){re.IteratorClose(i,true);throw s}}}}};var $r=function addIterableToSet(e,n,o){if(r(o)||K.string(o)){l(o,function(e){n.add(e)})}else if(o instanceof e){t(e.prototype.forEach,o,function(e){n.add(e)})}else{var i,a;if(o!==null&&typeof o!=="undefined"){a=n.add;if(!re.IsCallable(a)){throw new TypeError("bad set")}i=re.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=re.IteratorStep(i);if(u===false){break}var f=u.value;try{t(a,n,f)}catch(s){re.IteratorClose(i,true);throw s}}}}};var Ur={Map:function(){var e={};var r=function MapEntry(e,t){this.key=e;this.value=t;this.next=null;this.prev=null};r.prototype.isRemoved=function isRemoved(){return this.key===e};var n=function isMap(e){return!!e._es6map};var o=function requireMapSlot(e,t){if(!re.TypeIsObject(e)||!n(e)){throw new TypeError("Method Map.prototype."+t+" called on incompatible receiver "+re.ToString(e))}};var i=function MapIterator(e,t){o(e,"[[MapIterator]]");this.head=e._head;this.i=this.head;this.kind=t};i.prototype={next:function next(){var e=this.i;var t=this.kind;var r=this.head;if(typeof this.i==="undefined"){return Ge()}while(e.isRemoved()&&e!==r){e=e.prev}var n;while(e.next!==r){e=e.next;if(!e.isRemoved()){if(t==="key"){n=e.key}else if(t==="value"){n=e.value}else{n=[e.key,e.value]}this.i=e;return Ge(n)}}this.i=void 0;return Ge()}};we(i.prototype);var a;var u=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}if(this&&this._es6map){throw new TypeError("Bad construction")}var e=Te(this,Map,a,{_es6map:true,_head:null,_storage:Vr(),_size:0});var t=new r(null,null);t.next=t.prev=t;e._head=t;if(arguments.length>0){Br(Map,e,arguments[0])}return e};a=u.prototype;O.getter(a,"size",function(){if(typeof this._size==="undefined"){throw new TypeError("size method called on incompatible Map")}return this._size});b(a,{get:function get(e){o(this,"get");var t=Hr(e);if(t!==null){var r=this._storage[t];if(r){return r.value}else{return}}var n=this._head;var i=n;while((i=i.next)!==n){if(re.SameValueZero(i.key,e)){return i.value}}},has:function has(e){o(this,"has");var t=Hr(e);if(t!==null){return typeof this._storage[t]!=="undefined"}var r=this._head;var n=r;while((n=n.next)!==r){if(re.SameValueZero(n.key,e)){return true}}return false},set:function set(e,t){o(this,"set");var n=this._head;var i=n;var a;var u=Hr(e);if(u!==null){if(typeof this._storage[u]!=="undefined"){this._storage[u].value=t;return this}else{a=this._storage[u]=new r(e,t);i=n.prev}}while((i=i.next)!==n){if(re.SameValueZero(i.key,e)){i.value=t;return this}}a=a||new r(e,t);if(re.SameValue(-0,e)){a.key=+0}a.next=this._head;a.prev=this._head.prev;a.prev.next=a;a.next.prev=a;this._size+=1;return this},"delete":function(t){o(this,"delete");var r=this._head;var n=r;var i=Hr(t);if(i!==null){if(typeof this._storage[i]==="undefined"){return false}n=this._storage[i].prev;delete this._storage[i]}while((n=n.next)!==r){if(re.SameValueZero(n.key,t)){n.key=n.value=e;n.prev.next=n.next;n.next.prev=n.prev;this._size-=1;return true}}return false},clear:function clear(){o(this,"clear");this._size=0;this._storage=Vr();var t=this._head;var r=t;var n=r.next;while((r=n)!==t){r.key=r.value=e;n=r.next;r.next=r.prev=t}t.next=t.prev=t},keys:function keys(){o(this,"keys");return new i(this,"key")},values:function values(){o(this,"values");return new i(this,"value")},entries:function entries(){o(this,"entries");return new i(this,"key+value")},forEach:function forEach(e){o(this,"forEach");var r=arguments.length>1?arguments[1]:null;var n=this.entries();for(var i=n.next();!i.done;i=n.next()){if(r){t(e,r,i.value[1],i.value[0],this)}else{e(i.value[1],i.value[0],this)}}}});we(a,a.entries);return u}(),Set:function(){var e=function isSet(e){return e._es6set&&typeof e._storage!=="undefined"};var r=function requireSetSlot(t,r){if(!re.TypeIsObject(t)||!e(t)){throw new TypeError("Set.prototype."+r+" called on incompatible receiver "+re.ToString(t))}};var o;var i=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}if(this&&this._es6set){throw new TypeError("Bad construction")}var e=Te(this,Set,o,{_es6set:true,"[[SetData]]":null,_storage:Vr()});if(!e._es6set){throw new TypeError("bad set")}if(arguments.length>0){$r(Set,e,arguments[0])}return e};o=i.prototype;var a=function(e){var t=e;if(t==="^null"){return null}else if(t==="^undefined"){return void 0}else{var r=t.charAt(0);if(r==="$"){return C(t,1)}else if(r==="n"){return+C(t,1)}else if(r==="b"){return t==="btrue"}}return+t};var u=function ensureMap(e){if(!e["[[SetData]]"]){var t=e["[[SetData]]"]=new Ur.Map;l(n(e._storage),function(e){var r=a(e);t.set(r,r)});e["[[SetData]]"]=t}e._storage=null};O.getter(i.prototype,"size",function(){r(this,"size");if(this._storage){return n(this._storage).length}u(this);return this["[[SetData]]"].size});b(i.prototype,{has:function has(e){r(this,"has");var t;if(this._storage&&(t=Hr(e))!==null){return!!this._storage[t]}u(this);return this["[[SetData]]"].has(e)},add:function add(e){r(this,"add");var t;if(this._storage&&(t=Hr(e))!==null){this._storage[t]=true;return this}u(this);this["[[SetData]]"].set(e,e);return this},"delete":function(e){r(this,"delete");var t;if(this._storage&&(t=Hr(e))!==null){var n=z(this._storage,t);return delete this._storage[t]&&n}u(this);return this["[[SetData]]"]["delete"](e)},clear:function clear(){r(this,"clear");if(this._storage){this._storage=Vr()}if(this["[[SetData]]"]){this["[[SetData]]"].clear()}},values:function values(){r(this,"values");u(this);return this["[[SetData]]"].values()},entries:function entries(){r(this,"entries");u(this);return this["[[SetData]]"].entries()},forEach:function forEach(e){r(this,"forEach");var n=arguments.length>1?arguments[1]:null;var o=this;u(o);this["[[SetData]]"].forEach(function(r,i){if(n){t(e,n,i,i,o)}else{e(i,i,o)}})}});h(i.prototype,"keys",i.prototype.values,true);we(i.prototype,i.prototype.values);return i}()};if(S.Map||S.Set){var Jr=a(function(){return new Map([[1,2]]).get(1)===2});if(!Jr){var Xr=S.Map;S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new Xr;if(arguments.length>0){Br(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,S.Map.prototype);return e};S.Map.prototype=m(Xr.prototype);h(S.Map.prototype,"constructor",S.Map,true);O.preserveToString(S.Map,Xr)}var Kr=new Map;var Zr=function(){var e=new Map([[1,0],[2,0],[3,0],[4,0]]);e.set(-0,e);return e.get(0)===e&&e.get(-0)===e&&e.has(0)&&e.has(-0)}();var Yr=Kr.set(1,2)===Kr;if(!Zr||!Yr){var Qr=Map.prototype.set;Z(Map.prototype,"set",function set(e,r){t(Qr,this,e===0?0:e,r);return this})}if(!Zr){var en=Map.prototype.get;var tn=Map.prototype.has;b(Map.prototype,{get:function get(e){return t(en,this,e===0?0:e)},has:function has(e){return t(tn,this,e===0?0:e)}},true);O.preserveToString(Map.prototype.get,en);O.preserveToString(Map.prototype.has,tn)}var rn=new Set;var nn=function(e){e["delete"](0);e.add(-0);return!e.has(0)}(rn);var on=rn.add(1)===rn;if(!nn||!on){var an=Set.prototype.add;Set.prototype.add=function add(e){t(an,this,e===0?0:e);return this};O.preserveToString(Set.prototype.add,an)}if(!nn){var un=Set.prototype.has;Set.prototype.has=function has(e){return t(un,this,e===0?0:e)};O.preserveToString(Set.prototype.has,un);var fn=Set.prototype["delete"];Set.prototype["delete"]=function SetDelete(e){return t(fn,this,e===0?0:e)};O.preserveToString(Set.prototype["delete"],fn)}var sn=w(S.Map,function(e){var t=new e([]);t.set(42,42);return t instanceof e});var cn=Object.setPrototypeOf&&!sn;var ln=function(){try{return!(S.Map()instanceof S.Map)}catch(e){return e instanceof TypeError}}();if(S.Map.length!==0||cn||!ln){var pn=S.Map;S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new pn;if(arguments.length>0){Br(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Map.prototype);return e};S.Map.prototype=pn.prototype;h(S.Map.prototype,"constructor",S.Map,true);O.preserveToString(S.Map,pn)}var vn=w(S.Set,function(e){var t=new e([]);t.add(42,42);return t instanceof e});var yn=Object.setPrototypeOf&&!vn;var hn=function(){try{return!(S.Set()instanceof S.Set)}catch(e){return e instanceof TypeError}}();if(S.Set.length!==0||yn||!hn){var bn=S.Set;S.Set=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}var e=new bn;if(arguments.length>0){$r(Set,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Set.prototype);return e};S.Set.prototype=bn.prototype;h(S.Set.prototype,"constructor",S.Set,true);O.preserveToString(S.Set,bn)}var gn=new S.Map;var dn=!a(function(){return gn.keys().next().done});if(typeof S.Map.prototype.clear!=="function"||(new S.Set).size!==0||gn.size!==0||typeof S.Map.prototype.keys!=="function"||typeof S.Set.prototype.keys!=="function"||typeof S.Map.prototype.forEach!=="function"||typeof S.Set.prototype.forEach!=="function"||u(S.Map)||u(S.Set)||typeof gn.keys().next!=="function"||dn||!sn){b(S,{Map:Ur.Map,Set:Ur.Set},true)}if(S.Set.prototype.keys!==S.Set.prototype.values){h(S.Set.prototype,"keys",S.Set.prototype.values,true)}we(Object.getPrototypeOf((new S.Map).keys()));we(Object.getPrototypeOf((new S.Set).keys()));if(c&&S.Set.prototype.has.name!=="has"){var On=S.Set.prototype.has;Z(S.Set.prototype,"has",function has(e){return t(On,this,e)})}}b(S,Ur);me(S.Map);me(S.Set)}var mn=function throwUnlessTargetIsObject(e){if(!re.TypeIsObject(e)){throw new TypeError("target must be an object")}};var wn={apply:function apply(){return re.Call(re.Call,null,arguments)},construct:function construct(e,t){if(!re.IsConstructor(e)){throw new TypeError("First argument must be a constructor.")}var r=arguments.length>2?arguments[2]:e;if(!re.IsConstructor(r)){throw new TypeError("new.target must be a constructor.")}return re.Construct(e,t,r,"internal")},deleteProperty:function deleteProperty(e,t){mn(e);if(s){var r=Object.getOwnPropertyDescriptor(e,t);if(r&&!r.configurable){return false}}return delete e[t]},has:function has(e,t){mn(e);return t in e}};if(Object.getOwnPropertyNames){Object.assign(wn,{ownKeys:function ownKeys(e){mn(e);var t=Object.getOwnPropertyNames(e);if(re.IsCallable(Object.getOwnPropertySymbols)){x(t,Object.getOwnPropertySymbols(e))}return t}})}var jn=function ConvertExceptionToBoolean(e){return!i(e)};if(Object.preventExtensions){Object.assign(wn,{isExtensible:function isExtensible(e){mn(e);return Object.isExtensible(e)},preventExtensions:function preventExtensions(e){mn(e);return jn(function(){Object.preventExtensions(e)})}})}if(s){var Sn=function get(e,t,r){var n=Object.getOwnPropertyDescriptor(e,t);if(!n){var o=Object.getPrototypeOf(e);if(o===null){return void 0}return Sn(o,t,r)}if("value"in n){return n.value}if(n.get){return re.Call(n.get,r)}return void 0};var Tn=function set(e,r,n,o){var i=Object.getOwnPropertyDescriptor(e,r);if(!i){var a=Object.getPrototypeOf(e);if(a!==null){return Tn(a,r,n,o)}i={value:void 0,writable:true,enumerable:true,configurable:true}}if("value"in i){if(!i.writable){return false}if(!re.TypeIsObject(o)){return false}var u=Object.getOwnPropertyDescriptor(o,r);if(u){return ee.defineProperty(o,r,{value:n})}else{return ee.defineProperty(o,r,{value:n,writable:true,enumerable:true,configurable:true})}}if(i.set){t(i.set,o,n);return true}return false};Object.assign(wn,{defineProperty:function defineProperty(e,t,r){mn(e);return jn(function(){Object.defineProperty(e,t,r)})},getOwnPropertyDescriptor:function getOwnPropertyDescriptor(e,t){mn(e);return Object.getOwnPropertyDescriptor(e,t)},get:function get(e,t){mn(e);var r=arguments.length>2?arguments[2]:e;return Sn(e,t,r)},set:function set(e,t,r){mn(e);var n=arguments.length>3?arguments[3]:e;return Tn(e,t,r,n)}})}if(Object.getPrototypeOf){var In=Object.getPrototypeOf;wn.getPrototypeOf=function getPrototypeOf(e){mn(e);return In(e)}}if(Object.setPrototypeOf&&wn.getPrototypeOf){var En=function(e,t){var r=t;while(r){if(e===r){return true}r=wn.getPrototypeOf(r)}return false};Object.assign(wn,{setPrototypeOf:function setPrototypeOf(e,t){mn(e);if(t!==null&&!re.TypeIsObject(t)){throw new TypeError("proto must be an object or null")}if(t===ee.getPrototypeOf(e)){return true}if(ee.isExtensible&&!ee.isExtensible(e)){return false}if(En(e,t)){return false}Object.setPrototypeOf(e,t);return true}})}var Pn=function(e,t){if(!re.IsCallable(S.Reflect[e])){h(S.Reflect,e,t)}else{var r=a(function(){S.Reflect[e](1);S.Reflect[e](NaN);S.Reflect[e](true);return true});if(r){Z(S.Reflect,e,t)}}};Object.keys(wn).forEach(function(e){Pn(e,wn[e])});var Cn=S.Reflect.getPrototypeOf;if(c&&Cn&&Cn.name!=="getPrototypeOf"){Z(S.Reflect,"getPrototypeOf",function getPrototypeOf(e){return t(Cn,S.Reflect,e)})}if(S.Reflect.setPrototypeOf){if(a(function(){S.Reflect.setPrototypeOf(1,{});return true})){Z(S.Reflect,"setPrototypeOf",wn.setPrototypeOf)}}if(S.Reflect.defineProperty){if(!a(function(){var e=!S.Reflect.defineProperty(1,"test",{value:1});var t=typeof Object.preventExtensions!=="function"||!S.Reflect.defineProperty(Object.preventExtensions({}),"test",{});return e&&t})){Z(S.Reflect,"defineProperty",wn.defineProperty)}}if(S.Reflect.construct){if(!a(function(){var e=function F(){};return S.Reflect.construct(function(){},[],e)instanceof e})){Z(S.Reflect,"construct",wn.construct)}}if(String(new Date(NaN))!=="Invalid Date"){var Mn=Date.prototype.toString;var xn=function toString(){var e=+this;if(e!==e){return"Invalid Date"}return re.Call(Mn,this)};Z(Date.prototype,"toString",xn)}var Nn={anchor:function anchor(e){return re.CreateHTML(this,"a","name",e)},big:function big(){return re.CreateHTML(this,"big","","")},blink:function blink(){return re.CreateHTML(this,"blink","","")},bold:function bold(){return re.CreateHTML(this,"b","","")},fixed:function fixed(){return re.CreateHTML(this,"tt","","")},fontcolor:function fontcolor(e){return re.CreateHTML(this,"font","color",e)},fontsize:function fontsize(e){return re.CreateHTML(this,"font","size",e)},italics:function italics(){return re.CreateHTML(this,"i","","")},link:function link(e){return re.CreateHTML(this,"a","href",e)},small:function small(){return re.CreateHTML(this,"small","","")},strike:function strike(){return re.CreateHTML(this,"strike","","")},sub:function sub(){return re.CreateHTML(this,"sub","","")},sup:function sub(){return re.CreateHTML(this,"sup","","")}};l(Object.keys(Nn),function(e){var r=String.prototype[e];var n=false;if(re.IsCallable(r)){var o=t(r,"",' " ');var i=P([],o.match(/"/g)).length;n=o!==o.toLowerCase()||i>2}else{n=true}if(n){Z(String.prototype,e,Nn[e])}});var An=function(){if(!Y){return false}var e=typeof JSON==="object"&&typeof JSON.stringify==="function"?JSON.stringify:null;if(!e){return false}if(typeof e(G())!=="undefined"){return true}if(e([G()])!=="[null]"){return true}var t={a:G()};t[G()]=true;if(e(t)!=="{}"){return true}return false}();var Rn=a(function(){if(!Y){return true}return JSON.stringify(Object(G()))==="{}"&&JSON.stringify([Object(G())])==="[{}]"});if(An||!Rn){var _n=JSON.stringify;Z(JSON,"stringify",function stringify(e){if(typeof e==="symbol"){return}var n;if(arguments.length>1){n=arguments[1]}var o=[e];if(!r(n)){var i=re.IsCallable(n)?n:null;var a=function(e,r){var n=i?t(i,this,e,r):r;if(typeof n!=="symbol"){if(K.symbol(n)){return St({})(n)}else{return n}}};o.push(a)}else{o.push(n)}if(arguments.length>2){o.push(arguments[2])}return _n.apply(this,o)})}return S});
//# sourceMappingURL=es6-shim.map
/*! (C) WebReflection Mit Style License */
(function(e,t){"use strict";if(t in e)return;var n,r=typeof global==typeof r?window:global,i=0,s=""+Math.random(),o="__symbol:",u=o.length,a="__symbol@@"+s,f="defineProperty",l="defineProperties",c="getOwnPropertyNames",h="getOwnPropertyDescriptor",p="propertyIsEnumerable",d=e[c],v=e[h],m=e.create,g=e.keys,y=e.freeze||e,b=e[f],w=e[l],E=v(e,c),S=e.prototype,x=S.hasOwnProperty,T=S[p],N=S.toString,C=Array.prototype.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},k=function(e,t,n){x.call(e,a)||b(e,a,{enumerable:!1,configurable:!1,writable:!1,value:{}}),e[a]["@@"+t]=n},L=function(e,t){var n=m(e);return d(t).forEach(function(e){D.call(t,e)&&I(n,e,t[e])}),n},A=function(e){var t=m(e);return t.enumerable=!1,t},O=function(){},M=function(e){return e!=a&&!x.call(B,e)},_=function(e){return e!=a&&x.call(B,e)},D=function U(e){var t=""+e;return _(t)?x.call(this,t)&&this[a]["@@"+t]:T.call(this,e)},P=function(t){var r={enumerable:!1,configurable:!0,get:O,set:function(e){n(this,t,{enumerable:!1,configurable:!0,writable:!0,value:e}),k(this,t,!0)}};return b(S,t,r),y(B[t]=b(e(t),"constructor",j))},H=function(t){if(this&&this!==r)throw new TypeError("Symbol is not a constructor");return P(o.concat(t||"",s,++i))},B=m(null),j={value:H},F=function(e){return B[e]},I=function(t,r,i){var s=""+r;return _(s)?(n(t,s,i.enumerable?A(i):i),k(t,s,!!i.enumerable)):b(t,r,i),t},q=function(t){return d(t).filter(_).map(F)};E.value=I,b(e,f,E),E.value=q,b(e,t,E),E.value=function(t){return d(t).filter(M)},b(e,c,E),E.value=function(t,n){var r=q(n);return r.length?g(n).concat(r).forEach(function(e){D.call(n,e)&&I(t,e,n[e])}):w(t,n),t},b(e,l,E),E.value=D,b(S,p,E),E.value=H,b(r,"Symbol",E),E.value=function(e){var t=o.concat(o,e,s);return t in S?B[t]:P(t)},b(H,"for",E),E.value=function(e){if(M(e))throw new TypeError(e+" is not a symbol");return x.call(B,e)?e.slice(u*2,-s.length):void 0},b(H,"keyFor",E),E.value=function(t,n){var r=v(t,n);return r&&_(n)&&(r.enumerable=D.call(t,n)),r},b(e,h,E),E.value=function(e,t){return arguments.length===1?m(e):L(e,t)},b(e,"create",E),E.value=function(){var e=N.call(this);return e==="[object String]"&&_(this)?"[object Symbol]":e},b(S,"toString",E);try{n=m(b({},o,{get:function(){return b(this,o,{value:!1})[o]}}))[o]||b}catch(R){n=function(e,t,n){var r=v(S,t);delete S[t],b(e,t,n),b(S,t,r)}}})(Object,"getOwnPropertySymbols"),function(e,t){var n=e.defineProperty,r=e.prototype,i=r.toString,s="toStringTag",o;["iterator","match","replace","search","split","hasInstance","isConcatSpreadable","unscopables","species","toPrimitive",s].forEach(function(t){if(!(t in Symbol)){n(Symbol,t,{value:Symbol(t)});switch(t){case s:o=e.getOwnPropertyDescriptor(r,"toString"),o.value=function(){var e=i.call(this),t=this[Symbol.toStringTag];return typeof t=="undefined"?e:"[object "+t+"]"},n(r,"toString",o)}}})}(Object,Symbol),function(e,t,n){function r(){return this}t[e]||(t[e]=function(){var t=0,n=this,i={next:function(){var r=n.length<=t;return r?{done:r}:{done:r,value:n[t++]}}};return i[e]=r,i}),n[e]||(n[e]=function(){var t=String.fromCodePoint,n=this,i=0,s=n.length,o={next:function(){var r=s<=i,o=r?"":t(n.codePointAt(i));return i+=o.length,r?{done:r}:{done:r,value:o}}};return o[e]=r,o})}(Symbol.iterator,Array.prototype,String.prototype);
window.WebComponents = window.WebComponents || {};
WebComponents.flags = WebComponents.flags || {};
/* Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/ */

(function(scope) {
  'use strict';

  // feature detect for URL constructor
  var hasWorkingUrl = false;
  if (!scope.forceJURL) {
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      hasWorkingUrl = u.href === 'http://a/c%20d';
    } catch(e) {}
  }

  if (hasWorkingUrl)
    return;

  var relative = Object.create(null);
  relative['ftp'] = 21;
  relative['file'] = 0;
  relative['gopher'] = 70;
  relative['http'] = 80;
  relative['https'] = 443;
  relative['ws'] = 80;
  relative['wss'] = 443;

  var relativePathDotMapping = Object.create(null);
  relativePathDotMapping['%2e'] = '.';
  relativePathDotMapping['.%2e'] = '..';
  relativePathDotMapping['%2e.'] = '..';
  relativePathDotMapping['%2e%2e'] = '..';

  function isRelativeScheme(scheme) {
    return relative[scheme] !== undefined;
  }

  function invalid() {
    clear.call(this);
    this._isInvalid = true;
  }

  function IDNAToASCII(h) {
    if ('' == h) {
      invalid.call(this)
    }
    // XXX
    return h.toLowerCase()
  }

  function percentEscape(c) {
    var unicode = c.charCodeAt(0);
    if (unicode > 0x20 &&
       unicode < 0x7F &&
       // " # < > ? `
       [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1
      ) {
      return c;
    }
    return encodeURIComponent(c);
  }

  function percentEscapeQuery(c) {
    // XXX This actually needs to encode c using encoding and then
    // convert the bytes one-by-one.

    var unicode = c.charCodeAt(0);
    if (unicode > 0x20 &&
       unicode < 0x7F &&
       // " # < > ` (do not escape '?')
       [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1
      ) {
      return c;
    }
    return encodeURIComponent(c);
  }

  var EOF = undefined,
      ALPHA = /[a-zA-Z]/,
      ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

  function parse(input, stateOverride, base) {
    function err(message) {
      errors.push(message)
    }

    var state = stateOverride || 'scheme start',
        cursor = 0,
        buffer = '',
        seenAt = false,
        seenBracket = false,
        errors = [];

    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
      var c = input[cursor];
      switch (state) {
        case 'scheme start':
          if (c && ALPHA.test(c)) {
            buffer += c.toLowerCase(); // ASCII-safe
            state = 'scheme';
          } else if (!stateOverride) {
            buffer = '';
            state = 'no scheme';
            continue;
          } else {
            err('Invalid scheme.');
            break loop;
          }
          break;

        case 'scheme':
          if (c && ALPHANUMERIC.test(c)) {
            buffer += c.toLowerCase(); // ASCII-safe
          } else if (':' == c) {
            this._scheme = buffer;
            buffer = '';
            if (stateOverride) {
              break loop;
            }
            if (isRelativeScheme(this._scheme)) {
              this._isRelative = true;
            }
            if ('file' == this._scheme) {
              state = 'relative';
            } else if (this._isRelative && base && base._scheme == this._scheme) {
              state = 'relative or authority';
            } else if (this._isRelative) {
              state = 'authority first slash';
            } else {
              state = 'scheme data';
            }
          } else if (!stateOverride) {
            buffer = '';
            cursor = 0;
            state = 'no scheme';
            continue;
          } else if (EOF == c) {
            break loop;
          } else {
            err('Code point not allowed in scheme: ' + c)
            break loop;
          }
          break;

        case 'scheme data':
          if ('?' == c) {
            this._query = '?';
            state = 'query';
          } else if ('#' == c) {
            this._fragment = '#';
            state = 'fragment';
          } else {
            // XXX error handling
            if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
              this._schemeData += percentEscape(c);
            }
          }
          break;

        case 'no scheme':
          if (!base || !(isRelativeScheme(base._scheme))) {
            err('Missing scheme.');
            invalid.call(this);
          } else {
            state = 'relative';
            continue;
          }
          break;

        case 'relative or authority':
          if ('/' == c && '/' == input[cursor+1]) {
            state = 'authority ignore slashes';
          } else {
            err('Expected /, got: ' + c);
            state = 'relative';
            continue
          }
          break;

        case 'relative':
          this._isRelative = true;
          if ('file' != this._scheme)
            this._scheme = base._scheme;
          if (EOF == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            this._username = base._username;
            this._password = base._password;
            break loop;
          } else if ('/' == c || '\\' == c) {
            if ('\\' == c)
              err('\\ is an invalid code point.');
            state = 'relative slash';
          } else if ('?' == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = '?';
            this._username = base._username;
            this._password = base._password;
            state = 'query';
          } else if ('#' == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            this._fragment = '#';
            this._username = base._username;
            this._password = base._password;
            state = 'fragment';
          } else {
            var nextC = input[cursor+1]
            var nextNextC = input[cursor+2]
            if (
              'file' != this._scheme || !ALPHA.test(c) ||
              (nextC != ':' && nextC != '|') ||
              (EOF != nextNextC && '/' != nextNextC && '\\' != nextNextC && '?' != nextNextC && '#' != nextNextC)) {
              this._host = base._host;
              this._port = base._port;
              this._username = base._username;
              this._password = base._password;
              this._path = base._path.slice();
              this._path.pop();
            }
            state = 'relative path';
            continue;
          }
          break;

        case 'relative slash':
          if ('/' == c || '\\' == c) {
            if ('\\' == c) {
              err('\\ is an invalid code point.');
            }
            if ('file' == this._scheme) {
              state = 'file host';
            } else {
              state = 'authority ignore slashes';
            }
          } else {
            if ('file' != this._scheme) {
              this._host = base._host;
              this._port = base._port;
              this._username = base._username;
              this._password = base._password;
            }
            state = 'relative path';
            continue;
          }
          break;

        case 'authority first slash':
          if ('/' == c) {
            state = 'authority second slash';
          } else {
            err("Expected '/', got: " + c);
            state = 'authority ignore slashes';
            continue;
          }
          break;

        case 'authority second slash':
          state = 'authority ignore slashes';
          if ('/' != c) {
            err("Expected '/', got: " + c);
            continue;
          }
          break;

        case 'authority ignore slashes':
          if ('/' != c && '\\' != c) {
            state = 'authority';
            continue;
          } else {
            err('Expected authority, got: ' + c);
          }
          break;

        case 'authority':
          if ('@' == c) {
            if (seenAt) {
              err('@ already seen.');
              buffer += '%40';
            }
            seenAt = true;
            for (var i = 0; i < buffer.length; i++) {
              var cp = buffer[i];
              if ('\t' == cp || '\n' == cp || '\r' == cp) {
                err('Invalid whitespace in authority.');
                continue;
              }
              // XXX check URL code points
              if (':' == cp && null === this._password) {
                this._password = '';
                continue;
              }
              var tempC = percentEscape(cp);
              (null !== this._password) ? this._password += tempC : this._username += tempC;
            }
            buffer = '';
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            cursor -= buffer.length;
            buffer = '';
            state = 'host';
            continue;
          } else {
            buffer += c;
          }
          break;

        case 'file host':
          if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {
              state = 'relative path';
            } else if (buffer.length == 0) {
              state = 'relative path start';
            } else {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'relative path start';
            }
            continue;
          } else if ('\t' == c || '\n' == c || '\r' == c) {
            err('Invalid whitespace in file host.');
          } else {
            buffer += c;
          }
          break;

        case 'host':
        case 'hostname':
          if (':' == c && !seenBracket) {
            // XXX host parsing
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'port';
            if ('hostname' == stateOverride) {
              break loop;
            }
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'relative path start';
            if (stateOverride) {
              break loop;
            }
            continue;
          } else if ('\t' != c && '\n' != c && '\r' != c) {
            if ('[' == c) {
              seenBracket = true;
            } else if (']' == c) {
              seenBracket = false;
            }
            buffer += c;
          } else {
            err('Invalid code point in host/hostname: ' + c);
          }
          break;

        case 'port':
          if (/[0-9]/.test(c)) {
            buffer += c;
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c || stateOverride) {
            if ('' != buffer) {
              var temp = parseInt(buffer, 10);
              if (temp != relative[this._scheme]) {
                this._port = temp + '';
              }
              buffer = '';
            }
            if (stateOverride) {
              break loop;
            }
            state = 'relative path start';
            continue;
          } else if ('\t' == c || '\n' == c || '\r' == c) {
            err('Invalid code point in port: ' + c);
          } else {
            invalid.call(this);
          }
          break;

        case 'relative path start':
          if ('\\' == c)
            err("'\\' not allowed in path.");
          state = 'relative path';
          if ('/' != c && '\\' != c) {
            continue;
          }
          break;

        case 'relative path':
          if (EOF == c || '/' == c || '\\' == c || (!stateOverride && ('?' == c || '#' == c))) {
            if ('\\' == c) {
              err('\\ not allowed in relative path.');
            }
            var tmp;
            if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
              buffer = tmp;
            }
            if ('..' == buffer) {
              this._path.pop();
              if ('/' != c && '\\' != c) {
                this._path.push('');
              }
            } else if ('.' == buffer && '/' != c && '\\' != c) {
              this._path.push('');
            } else if ('.' != buffer) {
              if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {
                buffer = buffer[0] + ':';
              }
              this._path.push(buffer);
            }
            buffer = '';
            if ('?' == c) {
              this._query = '?';
              state = 'query';
            } else if ('#' == c) {
              this._fragment = '#';
              state = 'fragment';
            }
          } else if ('\t' != c && '\n' != c && '\r' != c) {
            buffer += percentEscape(c);
          }
          break;

        case 'query':
          if (!stateOverride && '#' == c) {
            this._fragment = '#';
            state = 'fragment';
          } else if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
            this._query += percentEscapeQuery(c);
          }
          break;

        case 'fragment':
          if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
            this._fragment += c;
          }
          break;
      }

      cursor++;
    }
  }

  function clear() {
    this._scheme = '';
    this._schemeData = '';
    this._username = '';
    this._password = null;
    this._host = '';
    this._port = '';
    this._path = [];
    this._query = '';
    this._fragment = '';
    this._isInvalid = false;
    this._isRelative = false;
  }

  // Does not process domain names or IP addresses.
  // Does not handle encoding for the query parameter.
  function jURL(url, base /* , encoding */) {
    if (base !== undefined && !(base instanceof jURL))
      base = new jURL(String(base));

    this._url = url;
    clear.call(this);

    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
    // encoding = encoding || 'utf-8'

    parse.call(this, input, null, base);
  }

  jURL.prototype = {
    toString: function() {
      return this.href;
    },
    get href() {
      if (this._isInvalid)
        return this._url;

      var authority = '';
      if ('' != this._username || null != this._password) {
        authority = this._username +
            (null != this._password ? ':' + this._password : '') + '@';
      }

      return this.protocol +
          (this._isRelative ? '//' + authority + this.host : '') +
          this.pathname + this._query + this._fragment;
    },
    set href(href) {
      clear.call(this);
      parse.call(this, href);
    },

    get protocol() {
      return this._scheme + ':';
    },
    set protocol(protocol) {
      if (this._isInvalid)
        return;
      parse.call(this, protocol + ':', 'scheme start');
    },

    get host() {
      return this._isInvalid ? '' : this._port ?
          this._host + ':' + this._port : this._host;
    },
    set host(host) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, host, 'host');
    },

    get hostname() {
      return this._host;
    },
    set hostname(hostname) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, hostname, 'hostname');
    },

    get port() {
      return this._port;
    },
    set port(port) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, port, 'port');
    },

    get pathname() {
      return this._isInvalid ? '' : this._isRelative ?
          '/' + this._path.join('/') : this._schemeData;
    },
    set pathname(pathname) {
      if (this._isInvalid || !this._isRelative)
        return;
      this._path = [];
      parse.call(this, pathname, 'relative path start');
    },

    get search() {
      return this._isInvalid || !this._query || '?' == this._query ?
          '' : this._query;
    },
    set search(search) {
      if (this._isInvalid || !this._isRelative)
        return;
      this._query = '?';
      if ('?' == search[0])
        search = search.slice(1);
      parse.call(this, search, 'query');
    },

    get hash() {
      return this._isInvalid || !this._fragment || '#' == this._fragment ?
          '' : this._fragment;
    },
    set hash(hash) {
      if (this._isInvalid)
        return;
      this._fragment = '#';
      if ('#' == hash[0])
        hash = hash.slice(1);
      parse.call(this, hash, 'fragment');
    },

    get origin() {
      var host;
      if (this._isInvalid || !this._scheme) {
        return '';
      }
      // javascript: Gecko returns String(""), WebKit/Blink String("null")
      // Gecko throws error for "data://"
      // data: Gecko returns "", Blink returns "data://", WebKit returns "null"
      // Gecko returns String("") for file: mailto:
      // WebKit/Blink returns String("SCHEME://") for file: mailto:
      switch (this._scheme) {
        case 'data':
        case 'file':
        case 'javascript':
        case 'mailto':
          return 'null';
      }
      host = this.host;
      if (!host) {
        return '';
      }
      return this._scheme + '://' + host;
    }
  };

  // Copy over the static methods
  var OriginalURL = scope.URL;
  if (OriginalURL) {
    jURL.createObjectURL = function(blob) {
      // IE extension allows a second optional options argument.
      // http://msdn.microsoft.com/en-us/library/ie/hh772302(v=vs.85).aspx
      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
    };
    jURL.revokeObjectURL = function(url) {
      OriginalURL.revokeObjectURL(url);
    };
  }

  scope.URL = jURL;

})(self);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

if (typeof WeakMap === 'undefined') {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;

    var WeakMap = function() {
      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
    };

    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key)
          entry[1] = value;
        else
          defineProperty(key, this.name, {value: [key, value], writable: true});
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ?
            entry[1] : undefined;
      },
      delete: function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };

    window.WeakMap = WeakMap;
  })();
};
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = (typeof HTMLTemplateElement === 'undefined');
  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // This needs to happen *after* patching importNode to fix template cloning
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8)
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement('template');
      var t2 = document.createElement('template');
      t2.content.appendChild(document.createElement('div'));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0);
    }
  })();

  var TEMPLATE_TAG = 'template';
  var TemplateImpl = function() {};

  if (needsTemplate) {

    var contentDoc = document.implementation.createHTMLDocument('template');
    var canDecorate = true;

    var templateStyle = document.createElement('style');
    templateStyle.textContent = TEMPLATE_TAG + '{display:none;}';

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    TemplateImpl.prototype = Object.create(HTMLElement.prototype);

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    TemplateImpl.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while (child = template.firstChild) {
        template.content.appendChild(child);
      }

      template.cloneNode = function(deep) {
        return TemplateImpl.cloneNode(this, deep);
      };

      // add innerHTML to template, if possible
      // Note: this throws on Safari 7
      if (canDecorate) {
        try {
          Object.defineProperty(template, 'innerHTML', {
            get: function() {
              var o = '';
              for (var e = this.content.firstChild; e; e = e.nextSibling) {
                o += e.outerHTML || escapeData(e.data);
              }
              return o;
            },
            set: function(text) {
              contentDoc.body.innerHTML = text;
              TemplateImpl.bootstrap(contentDoc);
              while (this.content.firstChild) {
                this.content.removeChild(this.content.firstChild);
              }
              while (contentDoc.body.firstChild) {
                this.content.appendChild(contentDoc.body.firstChild);
              }
            },
            configurable: true
          });

        } catch (err) {
          canDecorate = false;
        }
      }
      // bootstrap recursively
      TemplateImpl.bootstrap(template.content);
    };

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    TemplateImpl.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (var i=0, l=templates.length, t; (i<l) && (t=templates[i]); i++) {
        TemplateImpl.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener('DOMContentLoaded', function() {
      TemplateImpl.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    var createElement = document.createElement;
    document.createElement = function() {
      'use strict';
      var el = createElement.apply(document, arguments);
      if (el.localName === 'template') {
        TemplateImpl.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case '&':
          return '&amp;';
        case '<':
          return '&lt;';
        case '>':
          return '&gt;';
        case '\u00A0':
          return '&nbsp;';
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    // NOTE: we rely on this cloneNode not causing element upgrade.
    // This means this polyfill must load before the CE polyfill and
    // this would need to be re-worked if a browser supports native CE
    // but not <template>.
    var nativeCloneNode = Node.prototype.cloneNode;

    TemplateImpl.cloneNode = function(template, deep) {
      var clone = nativeCloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
            nativeCloneNode.call(template.content, true));
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    TemplateImpl.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i=0, l=t$.length, t, s; i<l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    var originalImportNode = document.importNode;

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom = nativeCloneNode.call(this, deep);
      // template.content is cloned iff `deep`.
      if (deep) {
        TemplateImpl.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    document.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return TemplateImpl.cloneNode(element, deep);
      } else {
        var dom = originalImportNode.call(document, element, deep);
        if (deep) {
          TemplateImpl.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return TemplateImpl.cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = TemplateImpl;
  }

})();
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(global) {

  // Don't allow this object to be redefined.
  if (global.JsMutationObserver) {
    return;
  }

  var registrationsTable = new WeakMap();

  var setImmediate;

  // As much as we would like to use the native implementation, IE
  // (all versions) suffers a rather annoying bug where it will drop or defer
  // callbacks when heavy DOM operations are being performed concurrently.
  //
  // For a thorough discussion on this, see:
  // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/
  if (/Trident|Edge/.test(navigator.userAgent)) {
    // Sadly, this bug also affects postMessage and MessageQueues.
    //
    // We would like to use the onreadystatechange hack for IE <= 10, but it is
    // dangerous in the polyfilled environment due to requiring that the
    // observed script element be in the document.
    setImmediate = setTimeout;

  // If some other browser ever implements it, let's prefer their native
  // implementation:
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;

  // Otherwise, we fall back to postMessage as a means of emulating the next
  // task semantics of setImmediate.
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener('message', function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, '*');
    };
  }

  // This is used to ensure that we never schedule 2 callas to setImmediate
  var isScheduled = false;

  // Keep track of observers that needs to be notified next time.
  var scheduledObservers = [];

  /**
   * Schedules |dispatchCallback| to be called in the future.
   * @param {MutationObserver} observer
   */
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }

  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill &&
        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||
        node;
  }

  function dispatchCallbacks() {
    // http://dom.spec.whatwg.org/#mutation-observers

    isScheduled = false; // Used to allow a new setImmediate call above.

    var observers = scheduledObservers;
    scheduledObservers = [];
    // Sort observers based on their creation UID (incremental).
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });

    var anyNonEmpty = false;
    observers.forEach(function(observer) {

      // 2.1, 2.2
      var queue = observer.takeRecords();
      // 2.3. Remove all transient registered observers whose observer is mo.
      removeTransientObserversFor(observer);

      // 2.4
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });

    // 3.
    if (anyNonEmpty)
      dispatchCallbacks();
  }

  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations)
        return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer)
          registration.removeTransientObservers();
      });
    });
  }

  /**
   * This function is used for the "For each registered observer observer (with
   * observer's options as options) in target's list of registered observers,
   * run these substeps:" and the "For each ancestor ancestor of target, and for
   * each registered observer observer (with options options) in ancestor's list
   * of registered observers, run these substeps:" part of the algorithms. The
   * |options.subtree| is checked to ensure that the callback is called
   * correctly.
   *
   * @param {Node} target
   * @param {function(MutationObserverInit):MutationRecord} callback
   */
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);

      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;

          // Only target ignores subtree.
          if (node !== target && !options.subtree)
            continue;

          var record = callback(options);
          if (record)
            registration.enqueue(record);
        }
      }
    }
  }

  var uidCounter = 0;

  /**
   * The class that maps to the DOM MutationObserver interface.
   * @param {Function} callback.
   * @constructor
   */
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }

  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);

      // 1.1
      if (!options.childList && !options.attributes && !options.characterData ||

          // 1.2
          options.attributeOldValue && !options.attributes ||

          // 1.3
          options.attributeFilter && options.attributeFilter.length &&
              !options.attributes ||

          // 1.4
          options.characterDataOldValue && !options.characterData) {

        throw new SyntaxError();
      }

      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);

      // 2
      // If target's list of registered observers already includes a registered
      // observer associated with the context object, replace that registered
      // observer's options with options.
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }

      // 3.
      // Otherwise, add a new registered observer to target's list of registered
      // observers with the context object as the observer and options as the
      // options, and add target to context object's list of nodes on which it
      // is registered.
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }

      registration.addListeners();
    },

    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
      this.records_ = [];
    },

    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };

  /**
   * @param {string} type
   * @param {Node} target
   * @constructor
   */
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }

  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  };

  // We keep track of the two (possibly one) records used in a single mutation.
  var currentRecord, recordWithOldValue;

  /**
   * Creates a record without |oldValue| and caches it as |currentRecord| for
   * later use.
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }

  /**
   * Gets or creates a record with |oldValue| based in the |currentRecord|
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue)
      return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }

  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }

  /**
   * @param {MutationRecord} record
   * @return {boolean} Whether the record represents a record from the current
   * mutation event.
   */
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }

  /**
   * Selects which record, if any, to replace the last record in the queue.
   * This returns |null| if no record should be replaced.
   *
   * @param {MutationRecord} lastRecord
   * @param {MutationRecord} newRecord
   * @param {MutationRecord}
   */
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord)
      return lastRecord;

    // Check if the the record we are adding represents the same record. If
    // so, we keep the one with the oldValue in it.
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
      return recordWithOldValue;

    return null;
  }

  /**
   * Class used to represent a registered observer.
   * @param {MutationObserver} observer
   * @param {Node} target
   * @param {MutationObserverInit} options
   * @constructor
   */
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }

  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;

      // There are cases where we replace the last record with the new record.
      // For example if the record represents the same mutation we need to use
      // the one with the oldValue. If we get same record (this can happen as we
      // walk up the tree) we ignore the new record.
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }

      records[length] = record;
    },

    addListeners: function() {
      this.addListeners_(this.target);
    },

    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.addEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.addEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.addEventListener('DOMNodeRemoved', this, true);
    },

    removeListeners: function() {
      this.removeListeners_(this.target);
    },

    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.removeEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.removeEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.removeEventListener('DOMNodeRemoved', this, true);
    },

    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     * @param {Node} node
     */
    addTransientObserver: function(node) {
      // Don't add transient observers on the target itself. We already have all
      // the required listeners set up on the target.
      if (node === this.target)
        return;

      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations)
        registrationsTable.set(node, registrations = []);

      // We know that registrations does not contain this because we already
      // checked if node === this.target.
      registrations.push(this);
    },

    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];

      transientObservedNodes.forEach(function(node) {
        // Transient observers are never added to the target.
        this.removeListeners_(node);

        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
    },

    handleEvent: function(e) {
      // Stop propagation since we are managing the propagation manually.
      // This means that other mutation events on the page will not work
      // correctly but that is by design.
      e.stopImmediatePropagation();

      switch (e.type) {
        case 'DOMAttrModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes

          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;

          // 1.
          var record = new getRecord('attributes', target);
          record.attributeName = name;
          record.attributeNamespace = namespace;

          // 2.
          var oldValue =
              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.attributes)
              return;

            // 3.2, 4.3
            if (options.attributeFilter && options.attributeFilter.length &&
                options.attributeFilter.indexOf(name) === -1 &&
                options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            // 3.3, 4.4
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.4, 4.5
            return record;
          });

          break;

        case 'DOMCharacterDataModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata
          var target = e.target;

          // 1.
          var record = getRecord('characterData', target);

          // 2.
          var oldValue = e.prevValue;


          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.characterData)
              return;

            // 3.2, 4.3
            if (options.characterDataOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.3, 4.4
            return record;
          });

          break;

        case 'DOMNodeRemoved':
          this.addTransientObserver(e.target);
          // Fall through.
        case 'DOMNodeInserted':
          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === 'DOMNodeInserted') {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {

            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;

          // 1.
          var record = getRecord('childList', e.target.parentNode);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;

          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
            // 2.1, 3.2
            if (!options.childList)
              return;

            // 2.2, 3.3
            return record;
          });

      }

      clearRecords();
    }
  };

  global.JsMutationObserver = JsMutationObserver;

  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    // Explicltly mark MO as polyfilled for user reference.
    JsMutationObserver._isPolyfilled = true;
  }

})(self);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope) {

  'use strict';

  // polyfill performance.now

  // Note: old Safari has performance, but not now().
  if (!(window.performance && window.performance.now)) {
    var start = Date.now();
    // only at millisecond precision
    window.performance = {now: function(){ return Date.now() - start; }};
  }

  // polyfill for requestAnimationFrame

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (function() {
      var nativeRaf = window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame;

      return nativeRaf ?
        function(callback) {
          return nativeRaf(function() {
            callback(performance.now());
          });
        } :
        function( callback ){
          return window.setTimeout(callback, 1000 / 60);
        };
    })();
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = (function() {
      return  window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        function(id) {
          clearTimeout(id);
        };
    })();
  }

  // defaultPrevented is broken in IE.
  // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called
  var workingDefaultPrevented = (function() {
    var e = document.createEvent('Event');
    e.initEvent('foo', true, true);
    e.preventDefault();
    return e.defaultPrevented;
  })();

  if (!workingDefaultPrevented) {
    var origPreventDefault = Event.prototype.preventDefault;
    Event.prototype.preventDefault = function() {
      if (!this.cancelable) {
        return;
      }

      origPreventDefault.call(this);

      Object.defineProperty(this, 'defaultPrevented', {
        get: function() {
          return true;
        },
        configurable: true
      });
    };
  }

  var isIE = /Trident/.test(navigator.userAgent);

  // CustomEvent constructor shim
  if (!window.CustomEvent || isIE && (typeof window.CustomEvent !== 'function')) {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent('CustomEvent');
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }

  // Event constructor shim
  if (!window.Event || isIE && (typeof window.Event !== 'function')) {
    var origEvent = window.Event;
    window.Event = function(inType, params) {
      params = params || {};
      var e = document.createEvent('Event');
      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
      return e;
    };
    if (origEvent) {
      for (var i in origEvent) {
        window.Event[i] = origEvent[i];
      }
    }
    window.Event.prototype = origEvent.prototype;
  }

  if (!window.MouseEvent || isIE && (typeof window.MouseEvent !== 'function')) {
    var origMouseEvent = window.MouseEvent;
    window.MouseEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent('MouseEvent');
      e.initMouseEvent(inType,
        Boolean(params.bubbles), Boolean(params.cancelable),
        params.view || window, params.detail,
        params.screenX, params.screenY, params.clientX, params.clientY,
        params.ctrlKey, params.altKey, params.shiftKey, params.metaKey,
        params.button, params.relatedTarget);
      return e;
    };
    if (origMouseEvent) {
      for (var i in origMouseEvent) {
        window.MouseEvent[i] = origMouseEvent[i];
      }
    }
    window.MouseEvent.prototype = origMouseEvent.prototype;
  }

})(window.WebComponents);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/*
 * PLEASE NOTE: This file is duplicated within Polymer. Please keep it in sync!
 * https://github.com/Polymer/polymer/blob/master/src/system/HTMLImports/base.js
 */

/*
	Create polyfill scope and feature detect native support.
*/
window.HTMLImports = window.HTMLImports || {flags:{}};

(function(scope) {

/**
	Basic setup and simple module executer. We collect modules and then execute
  the code later, only if it's necessary for polyfilling.
*/
var IMPORT_LINK_TYPE = 'import';
var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement('link'));

/**
  Support `currentScript` on all browsers as `document._currentScript.`

  NOTE: We cannot polyfill `document.currentScript` because it's not possible
  both to override and maintain the ability to capture the native value.
  Therefore we choose to expose `_currentScript` both when native imports
  and the polyfill are in use.
*/
// NOTE: ShadowDOMPolyfill intrusion.
var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
var wrap = function(node) {
  return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
};
var rootDocument = wrap(document);

var currentScriptDescriptor = {
  get: function() {
    var script = window.HTMLImports.currentScript || document.currentScript ||
        // NOTE: only works when called in synchronously executing code.
        // readyState should check if `loading` but IE10 is
        // interactive when scripts run so we cheat.
        (document.readyState !== 'complete' ?
        document.scripts[document.scripts.length - 1] : null);
    return wrap(script);
  },
  configurable: true
};

Object.defineProperty(document, '_currentScript', currentScriptDescriptor);
Object.defineProperty(rootDocument, '_currentScript', currentScriptDescriptor);

/**
  Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`
  method. This api is necessary because unlike the native implementation,
  script elements do not force imports to resolve. Instead, users should wrap
  code in either an `HTMLImportsLoaded` handler or after load time in an
  `HTMLImports.whenReady(callback)` call.

  NOTE: This module also supports these apis under the native implementation.
  Therefore, if this file is loaded, the same code can be used under both
  the polyfill and native implementation.
 */

var isIE = /Trident/.test(navigator.userAgent);

// call a callback when all HTMLImports in the document at call time
// (or at least document ready) have loaded.
// 1. ensure the document is in a ready state (has dom), then
// 2. watch for loading of imports and call callback when done
function whenReady(callback, doc) {
  doc = doc || rootDocument;
  // if document is loading, wait and try again
  whenDocumentReady(function() {
    watchImportsLoad(callback, doc);
  }, doc);
}

// call the callback when the document is in a ready state (has dom)
var requiredReadyState = isIE ? 'complete' : 'interactive';
var READY_EVENT = 'readystatechange';
function isDocumentReady(doc) {
  return (doc.readyState === 'complete' ||
      doc.readyState === requiredReadyState);
}

// call <callback> when we ensure the document is in a ready state
function whenDocumentReady(callback, doc) {
  if (!isDocumentReady(doc)) {
    var checkReady = function() {
      if (doc.readyState === 'complete' ||
          doc.readyState === requiredReadyState) {
        doc.removeEventListener(READY_EVENT, checkReady);
        whenDocumentReady(callback, doc);
      }
    };
    doc.addEventListener(READY_EVENT, checkReady);
  } else if (callback) {
    callback();
  }
}

function markTargetLoaded(event) {
  event.target.__loaded = true;
}

// call <callback> when we ensure all imports have loaded
function watchImportsLoad(callback, doc) {
  var imports = doc.querySelectorAll('link[rel=import]');
  var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];
  function checkDone() {
    if (parsedCount == importCount && callback) {
      callback({
        allImports: imports,
        loadedImports: newImports,
        errorImports: errorImports
      });
    }
  }
  function loadedImport(e) {
    markTargetLoaded(e);
    newImports.push(this);
    parsedCount++;
    checkDone();
  }
  function errorLoadingImport(e) {
    errorImports.push(this);
    parsedCount++;
    checkDone();
  }
  if (importCount) {
    for (var i=0, imp; i<importCount && (imp=imports[i]); i++) {
      if (isImportLoaded(imp)) {
        newImports.push(this);
        parsedCount++;
        checkDone();
      } else {
        imp.addEventListener('load', loadedImport);
        imp.addEventListener('error', errorLoadingImport);
      }
    }
  } else {
    checkDone();
  }
}

// NOTE: test for native imports loading is based on explicitly watching
// all imports (see below).
// However, we cannot rely on this entirely without watching the entire document
// for import links. For perf reasons, currently only head is watched.
// Instead, we fallback to checking if the import property is available
// and the document is not itself loading.
function isImportLoaded(link) {
  return useNative ? link.__loaded ||
      (link.import && link.import.readyState !== 'loading') :
      link.__importParsed;
}

// TODO(sorvell): Workaround for
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when
// this bug is addressed.
// (1) Install a mutation observer to see when HTMLImports have loaded
// (2) if this script is run during document load it will watch any existing
// imports for loading.
//
// NOTE: The workaround has restricted functionality: (1) it's only compatible
// with imports that are added to document.head since the mutation observer
// watches only head for perf reasons, (2) it requires this script
// to run before any imports have completed loading.
if (useNative) {
  new MutationObserver(function(mxns) {
    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {
      if (m.addedNodes) {
        handleImports(m.addedNodes);
      }
    }
  }).observe(document.head, {childList: true});

  function handleImports(nodes) {
    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {
      if (isImport(n)) {
        handleImport(n);
      }
    }
  }

  function isImport(element) {
    return element.localName === 'link' && element.rel === 'import';
  }

  function handleImport(element) {
    var loaded = element.import;
    if (loaded) {
      markTargetLoaded({target: element});
    } else {
      element.addEventListener('load', markTargetLoaded);
      element.addEventListener('error', markTargetLoaded);
    }
  }

  // make sure to catch any imports that are in the process of loading
  // when this script is run.
  (function() {
    if (document.readyState === 'loading') {
      var imports = document.querySelectorAll('link[rel=import]');
      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {
        handleImport(imp);
      }
    }
  })();

}

// Fire the 'HTMLImportsLoaded' event when imports in document at load time
// have loaded. This event is required to simulate the script blocking
// behavior of native imports. A main document script that needs to be sure
// imports have loaded should wait for this event.
whenReady(function(detail) {
  window.HTMLImports.ready = true;
  window.HTMLImports.readyTime = new Date().getTime();
  var evt = rootDocument.createEvent("CustomEvent");
  evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);
  rootDocument.dispatchEvent(evt);
});

// exports
scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
scope.useNative = useNative;
scope.rootDocument = rootDocument;
scope.whenReady = whenReady;
scope.isIE = isIE;

})(window.HTMLImports);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
(function(scope) {

// world's simplest module initializer
var modules = [];
var addModule = function(module) {
	modules.push(module);
};

var initializeModules = function() {
	modules.forEach(function(module) {
		module(scope);
	});
};

// exports
scope.addModule = addModule;
scope.initializeModules = initializeModules;

})(window.HTMLImports);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;

// path fixup: style elements in imports must be made relative to the main
// document. We fixup url's in url() and @import.
var path = {

  resolveUrlsInStyle: function(style, linkUrl) {
    var doc = style.ownerDocument;
    var resolver = doc.createElement('a');
    style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
    return style;
  },

  resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {
    var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
    r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
    return r;
  },

  replaceUrls: function(text, urlObj, linkUrl, regexp) {
    return text.replace(regexp, function(m, pre, url, post) {
      var urlPath = url.replace(/["']/g, '');
      if (linkUrl) {
        urlPath = (new URL(urlPath, linkUrl)).href;
      }
      urlObj.href = urlPath;
      urlPath = urlObj.href;
      return pre + '\'' + urlPath + '\'' + post;
    });
  }

};

// exports
scope.path = path;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

/*
  xhr processor.
*/
var xhr = {
  async: true,

  ok: function(request) {
    return (request.status >= 200 && request.status < 300)
        || (request.status === 304)
        || (request.status === 0);
  },

  load: function(url, next, nextContext) {
    var request = new XMLHttpRequest();
    if (scope.flags.debug || scope.flags.bust) {
      url += '?' + Math.random();
    }
    request.open('GET', url, xhr.async);
    request.addEventListener('readystatechange', function(e) {
      if (request.readyState === 4) {
        // Servers redirecting an import can add a Location header to help us
        // polyfill correctly.
        var redirectedUrl = null;
        try {
          var locationHeader = request.getResponseHeader("Location");
          if (locationHeader) {
            redirectedUrl = (locationHeader.substr( 0, 1 ) === "/")
              ? location.origin + locationHeader  // Location is a relative path
              : locationHeader;                   // Full path
          }
        } catch ( e ) {
            console.error( e.message );
        }
        next.call(nextContext, !xhr.ok(request) && request,
            request.response || request.responseText, redirectedUrl);
      }
    });
    request.send();
    return request;
  },

  loadDocument: function(url, next, nextContext) {
    this.load(url, next, nextContext).responseType = 'document';
  }

};

// exports
scope.xhr = xhr;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

// imports
var xhr = scope.xhr;
var flags = scope.flags;

// This loader supports a dynamic list of urls
// and an oncomplete callback that is called when the loader is done.
// NOTE: The polyfill currently does *not* need this dynamism or the
// onComplete concept. Because of this, the loader could be simplified
// quite a bit.
var Loader = function(onLoad, onComplete) {
  this.cache = {};
  this.onload = onLoad;
  this.oncomplete = onComplete;
  this.inflight = 0;
  this.pending = {};
};

Loader.prototype = {

  addNodes: function(nodes) {
    // number of transactions to complete
    this.inflight += nodes.length;
    // commence transactions
    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {
      this.require(n);
    }
    // anything to do?
    this.checkDone();
  },

  addNode: function(node) {
    // number of transactions to complete
    this.inflight++;
    // commence transactions
    this.require(node);
    // anything to do?
    this.checkDone();
  },

  require: function(elt) {
    var url = elt.src || elt.href;
    // ensure we have a standard url that can be used
    // reliably for deduping.
    // TODO(sjmiles): ad-hoc
    elt.__nodeUrl = url;
    // deduplication
    if (!this.dedupe(url, elt)) {
      // fetch this resource
      this.fetch(url, elt);
    }
  },

  dedupe: function(url, elt) {
    if (this.pending[url]) {
      // add to list of nodes waiting for inUrl
      this.pending[url].push(elt);
      // don't need fetch
      return true;
    }
    var resource;
    if (this.cache[url]) {
      this.onload(url, elt, this.cache[url]);
      // finished this transaction
      this.tail();
      // don't need fetch
      return true;
    }
    // first node waiting for inUrl
    this.pending[url] = [elt];
    // need fetch (not a dupe)
    return false;
  },

  fetch: function(url, elt) {
    flags.load && console.log('fetch', url, elt);
    if (!url) {
      setTimeout(function() {
        this.receive(url, elt, {error: 'href must be specified'}, null);
      }.bind(this), 0);
    } else if (url.match(/^data:/)) {
      // Handle Data URI Scheme
      var pieces = url.split(',');
      var header = pieces[0];
      var body = pieces[1];
      if(header.indexOf(';base64') > -1) {
        body = atob(body);
      } else {
        body = decodeURIComponent(body);
      }
      setTimeout(function() {
          this.receive(url, elt, null, body);
      }.bind(this), 0);
    } else {
      var receiveXhr = function(err, resource, redirectedUrl) {
        this.receive(url, elt, err, resource, redirectedUrl);
      }.bind(this);
      xhr.load(url, receiveXhr);
    }
  },

  receive: function(url, elt, err, resource, redirectedUrl) {
    this.cache[url] = resource;
    var $p = this.pending[url];
    for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {
      // If url was redirected, use the redirected location so paths are
      // calculated relative to that.
      this.onload(url, p, resource, err, redirectedUrl);
      this.tail();
    }
    this.pending[url] = null;
  },

  tail: function() {
    --this.inflight;
    this.checkDone();
  },

  checkDone: function() {
    if (!this.inflight) {
      this.oncomplete();
    }
  }

};

// exports
scope.Loader = Loader;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

/*
  Use a mutation observer to call a callback for all added nodes.
*/
var Observer = function(addCallback) {
  this.addCallback = addCallback;
  this.mo = new MutationObserver(this.handler.bind(this));
};

Observer.prototype = {

  // we track mutations for addedNodes, looking for imports
  handler: function(mutations) {
    for (var i=0, l=mutations.length, m; (i<l) && (m=mutations[i]); i++) {
      if (m.type === 'childList' && m.addedNodes.length) {
        this.addedNodes(m.addedNodes);
      }
    }
  },

  addedNodes: function(nodes) {
    if (this.addCallback) {
      this.addCallback(nodes);
    }
    for (var i=0, l=nodes.length, n, loading; (i<l) && (n=nodes[i]); i++) {
      if (n.children && n.children.length) {
        this.addedNodes(n.children);
      }
    }
  },

  observe: function(root) {
    this.mo.observe(root, {childList: true, subtree: true});
  }

};

// exports
scope.Observer = Observer;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

// imports
var path = scope.path;
var rootDocument = scope.rootDocument;
var flags = scope.flags;
var isIE = scope.isIE;
var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
var IMPORT_SELECTOR = 'link[rel=' + IMPORT_LINK_TYPE + ']';

// importParser
// highlander object to manage parsing of imports
// parses import related elements and ensures proper parse order
// parse order is enforced by crawling the tree and monitoring which elements
// have been parsed;
// elements can be dynamically added to imports. These are maintained in a
// separate queue and parsed after all other elements.
var importParser = {

  // parse selectors for main document elements
  documentSelectors: IMPORT_SELECTOR,

  // parse selectors for import document elements
  importsSelectors: [
    IMPORT_SELECTOR,
    'link[rel=stylesheet]:not([type])',
    'style:not([type])',
    'script:not([type])',
    'script[type="application/javascript"]',
    'script[type="text/javascript"]'
  ].join(','),

  map: {
    link: 'parseLink',
    script: 'parseScript',
    style: 'parseStyle'
  },

  dynamicElements: [],

  // try to parse the next import in the tree
  parseNext: function() {
    var next = this.nextToParse();
    if (next) {
      this.parse(next);
    }
  },

  parse: function(elt) {
    if (this.isParsed(elt)) {
      flags.parse && console.log('[%s] is already parsed', elt.localName);
      return;
    }
    var fn = this[this.map[elt.localName]];
    if (fn) {
      this.markParsing(elt);
      fn.call(this, elt);
    }
  },

  // marks an element for dynamic parsing and attempts to parse the next element
  parseDynamic: function(elt, quiet) {
    this.dynamicElements.push(elt);
    if (!quiet) {
      this.parseNext();
    }
  },

  // only 1 element may be parsed at a time; parsing is async so each
  // parsing implementation must inform the system that parsing is complete
  // via markParsingComplete.
  // To prompt the system to parse the next element, parseNext should then be
  // called.
  // Note, parseNext used to be included at the end of markParsingComplete, but
  // we must not do this so that, for example, we can (1) mark parsing complete
  // then (2) fire an import load event, and then (3) parse the next resource.
  markParsing: function(elt) {
    flags.parse && console.log('parsing', elt);
    this.parsingElement = elt;
  },

  markParsingComplete: function(elt) {
    elt.__importParsed = true;
    this.markDynamicParsingComplete(elt);
    if (elt.__importElement) {
      elt.__importElement.__importParsed = true;
      this.markDynamicParsingComplete(elt.__importElement);
    }
    this.parsingElement = null;
    flags.parse && console.log('completed', elt);
  },

  markDynamicParsingComplete: function(elt) {
    var i = this.dynamicElements.indexOf(elt);
    if (i >= 0) {
      this.dynamicElements.splice(i, 1);
    }
  },

  parseImport: function(elt) {
    elt.import = elt.__doc;
    if (window.HTMLImports.__importsParsingHook) {
      window.HTMLImports.__importsParsingHook(elt);
    }
    if (elt.import) {
      elt.import.__importParsed = true;
    }
    this.markParsingComplete(elt);
    // fire load event
    if (elt.__resource && !elt.__error) {
      elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));
    } else {
      elt.dispatchEvent(new CustomEvent('error', {bubbles: false}));
    }
    // TODO(sorvell): workaround for Safari addEventListener not working
    // for elements not in the main document.
    if (elt.__pending) {
      var fn;
      while (elt.__pending.length) {
        fn = elt.__pending.shift();
        if (fn) {
          fn({target: elt});
        }
      }
    }
    this.parseNext();
  },

  parseLink: function(linkElt) {
    if (nodeIsImport(linkElt)) {
      this.parseImport(linkElt);
    } else {
      // make href absolute
      linkElt.href = linkElt.href;
      this.parseGeneric(linkElt);
    }
  },

  parseStyle: function(elt) {
    // TODO(sorvell): style element load event can just not fire so clone styles
    var src = elt;
    elt = cloneStyle(elt);
    src.__appliedElement = elt;
    elt.__importElement = src;
    this.parseGeneric(elt);
  },

  parseGeneric: function(elt) {
    this.trackElement(elt);
    this.addElementToDocument(elt);
  },

  rootImportForElement: function(elt) {
    var n = elt;
    while (n.ownerDocument.__importLink) {
      n = n.ownerDocument.__importLink;
    }
    return n;
  },

  addElementToDocument: function(elt) {
    var port = this.rootImportForElement(elt.__importElement || elt);
    port.parentNode.insertBefore(elt, port);
  },

  // tracks when a loadable element has loaded
  trackElement: function(elt, callback) {
    var self = this;
    var done = function(e) {
      // make sure we don't get multiple load/error signals (FF seems to do
      // this sometimes when <style> elments change)
      elt.removeEventListener('load', done);
      elt.removeEventListener('error', done);
      if (callback) {
        callback(e);
      }
      self.markParsingComplete(elt);
      self.parseNext();
    };
    elt.addEventListener('load', done);
    elt.addEventListener('error', done);

    // NOTE: IE does not fire "load" event for styles that have already loaded
    // This is in violation of the spec, so we try our hardest to work around it
    if (isIE && elt.localName === 'style') {
      var fakeLoad = false;
      // If there's not @import in the textContent, assume it has loaded
      if (elt.textContent.indexOf('@import') == -1) {
        fakeLoad = true;
      // if we have a sheet, we have been parsed
      } else if (elt.sheet) {
        fakeLoad = true;
        var csr = elt.sheet.cssRules;
        var len = csr ? csr.length : 0;
        // search the rules for @import's
        for (var i = 0, r; (i < len) && (r = csr[i]); i++) {
          if (r.type === CSSRule.IMPORT_RULE) {
            // if every @import has resolved, fake the load
            fakeLoad = fakeLoad && Boolean(r.styleSheet);
          }
        }
      }
      // dispatch a fake load event and continue parsing
      if (fakeLoad) {
        // Fire async, to prevent reentrancy
        setTimeout(function() {
          elt.dispatchEvent(new CustomEvent('load', {bubbles: false}));
        });
      }
    }
  },

  // NOTE: execute scripts by injecting them and watching for the load/error
  // event. Inline scripts are handled via dataURL's because browsers tend to
  // provide correct parsing errors in this case. If this has any compatibility
  // issues, we can switch to injecting the inline script with textContent.
  parseScript: function(scriptElt) {
    var script = document.createElement('script');
    script.__importElement = scriptElt;
    script.src = scriptElt.src ? scriptElt.src :
        generateScriptDataUrl(scriptElt);
    // keep track of executing script to help polyfill `document.currentScript`
    scope.currentScript = scriptElt;
    this.trackElement(script, function(e) {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
      scope.currentScript = null;
    });
    this.addElementToDocument(script);
  },

  // determine the next element in the tree which should be parsed
  // crawl the document tree to find the next unparsed element
  // then process any dynamically added elements (these should process in 'add'
  // order.
  nextToParse: function() {
    this._mayParse = [];
    return !this.parsingElement && (this.nextToParseInDoc(rootDocument) ||
        this.nextToParseDynamic());
  },

  nextToParseInDoc: function(doc, link) {
    // use `marParse` list to avoid looping into the same document again
    // since it could cause an iloop.
    if (doc && this._mayParse.indexOf(doc) < 0) {
      this._mayParse.push(doc);
      var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
      for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {
        if (!this.isParsed(n)) {
          if (this.hasResource(n)) {
            return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
          } else {
            return;
          }
        }
      }
    }
    // all nodes have been parsed, ready to parse import, if any
    return link;
  },

  // note dynamically added elements are stored in a separate queue
  nextToParseDynamic: function() {
    return this.dynamicElements[0];
  },

  // return the set of parse selectors relevant for this node.
  parseSelectorsForNode: function(node) {
    var doc = node.ownerDocument || node;
    return doc === rootDocument ? this.documentSelectors :
        this.importsSelectors;
  },

  isParsed: function(node) {
    return node.__importParsed;
  },

  needsDynamicParsing: function(elt) {
    return (this.dynamicElements.indexOf(elt) >= 0);
  },

  hasResource: function(node) {
    if (nodeIsImport(node) && (node.__doc === undefined)) {
      return false;
    }
    return true;
  }

};

function nodeIsImport(elt) {
  return (elt.localName === 'link') && (elt.rel === IMPORT_LINK_TYPE);
}

function generateScriptDataUrl(script) {
  var scriptContent = generateScriptContent(script);
  return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(scriptContent);
}

function generateScriptContent(script) {
  return script.textContent + generateSourceMapHint(script);
}

// calculate source map hint
function generateSourceMapHint(script) {
  var owner = script.ownerDocument;
  owner.__importedScripts = owner.__importedScripts || 0;
  var moniker = script.ownerDocument.baseURI;
  var num = owner.__importedScripts ? '-' + owner.__importedScripts : '';
  owner.__importedScripts++;
  return '\n//# sourceURL=' + moniker + num + '.js\n';
}

// style/stylesheet handling

// clone style with proper path resolution for main document
// NOTE: styles are the only elements that require direct path fixup.
function cloneStyle(style) {
  var clone = style.ownerDocument.createElement('style');
  clone.textContent = style.textContent;
  path.resolveUrlsInStyle(clone);
  return clone;
}

// exports
scope.parser = importParser;
scope.IMPORT_SELECTOR = IMPORT_SELECTOR;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

// imports
var flags = scope.flags;
var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
var rootDocument = scope.rootDocument;
var Loader = scope.Loader;
var Observer = scope.Observer;
var parser = scope.parser;

// importer
// highlander object to manage loading of imports
// for any document, importer:
// - loads any linked import documents (with deduping)
// - whenever an import is loaded, prompts the parser to try to parse
// - observes imported documents for new elements (these are handled via the
// dynamic importer)
var importer = {

  documents: {},

  // nodes to load in the mian document
  documentPreloadSelectors: IMPORT_SELECTOR,

  // nodes to load in imports
  importsPreloadSelectors: [
    IMPORT_SELECTOR
  ].join(','),

  loadNode: function(node) {
    importLoader.addNode(node);
  },

  // load all loadable elements within the parent element
  loadSubtree: function(parent) {
    var nodes = this.marshalNodes(parent);
    // add these nodes to loader's queue
    importLoader.addNodes(nodes);
  },

  marshalNodes: function(parent) {
    // all preloadable nodes in inDocument
    return parent.querySelectorAll(this.loadSelectorsForNode(parent));
  },

  // find the proper set of load selectors for a given node
  loadSelectorsForNode: function(node) {
    var doc = node.ownerDocument || node;
    return doc === rootDocument ? this.documentPreloadSelectors :
        this.importsPreloadSelectors;
  },

  loaded: function(url, elt, resource, err, redirectedUrl) {
    flags.load && console.log('loaded', url, elt);
    // store generic resource
    // TODO(sorvell): fails for nodes inside <template>.content
    // see https://code.google.com/p/chromium/issues/detail?id=249381.
    elt.__resource = resource;
    elt.__error = err;
    if (isImportLink(elt)) {
      var doc = this.documents[url];
      // if we've never seen a document at this url
      if (doc === undefined) {
        // generate an HTMLDocument from data
        doc = err ? null : makeDocument(resource, redirectedUrl || url);
        if (doc) {
          doc.__importLink = elt;
          // note, we cannot use MO to detect parsed nodes because
          // SD polyfill does not report these as mutations.
          this.bootDocument(doc);
        }
        // cache document
        this.documents[url] = doc;
      }
      // don't store import record until we're actually loaded
      // store document resource
      elt.__doc = doc;
    }
    parser.parseNext();
  },

  bootDocument: function(doc) {
    this.loadSubtree(doc);
    // observe documents for new elements being added
    this.observer.observe(doc);
    parser.parseNext();
  },

  loadedAll: function() {
    parser.parseNext();
  }

};

// loader singleton to handle loading imports
var importLoader = new Loader(importer.loaded.bind(importer),
    importer.loadedAll.bind(importer));

// observer singleton to handle observing elements in imports
// NOTE: the observer has a node added callback and this is set
// by the dynamic importer module.
importer.observer = new Observer();

function isImportLink(elt) {
  return isLinkRel(elt, IMPORT_LINK_TYPE);
}

function isLinkRel(elt, rel) {
  return elt.localName === 'link' && elt.getAttribute('rel') === rel;
}

function hasBaseURIAccessor(doc) {
  return !! Object.getOwnPropertyDescriptor(doc, 'baseURI');
}

function makeDocument(resource, url) {
  // create a new HTML document
  var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
  // cache the new document's source url
  doc._URL = url;
  // establish a relative path via <base>
  var base = doc.createElement('base');
  base.setAttribute('href', url);
  // add baseURI support to browsers (IE) that lack it.
  if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
    // Use defineProperty since Safari throws an exception when using assignment.
    Object.defineProperty(doc, 'baseURI', {value:url});
  }
  // ensure UTF-8 charset
  var meta = doc.createElement('meta');
  meta.setAttribute('charset', 'utf-8');

  doc.head.appendChild(meta);
  doc.head.appendChild(base);
  // install html
  doc.body.innerHTML = resource;
  // TODO(sorvell): ideally this code is not aware of Template polyfill,
  // but for now the polyfill needs help to bootstrap these templates
  if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
    HTMLTemplateElement.bootstrap(doc);
  }
  return doc;
}

// Polyfill document.baseURI for browsers without it.
if (!document.baseURI) {
  var baseURIDescriptor = {
    get: function() {
      var base = document.querySelector('base');
      return base ? base.href : window.location.href;
    },
    configurable: true
  };

  Object.defineProperty(document, 'baseURI', baseURIDescriptor);
  Object.defineProperty(rootDocument, 'baseURI', baseURIDescriptor);
}

// exports
scope.importer = importer;
scope.importLoader = importLoader;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
window.HTMLImports.addModule(function(scope) {

// imports
var parser = scope.parser;
var importer = scope.importer;

// dynamic
// highlander object to manage elements dynamically added to imports
// for any observed document, dynamic:
// - tells the importer to load any imports that are added.
// - tells the parser to parse any added elements that need to be parsed.
// dynamic importer)
var dynamic = {
  // process (load/parse) any nodes added to imported documents.
  added: function(nodes) {
    var owner, parsed, loading;
    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {
      if (!owner) {
        owner = n.ownerDocument;
        parsed = parser.isParsed(owner);
      }
      // note: the act of loading kicks the parser, so we use parseDynamic's
      // 2nd argument to control if this added node needs to kick the parser.
      loading = this.shouldLoadNode(n);
      if (loading) {
        importer.loadNode(n);
      }
      if (this.shouldParseNode(n) && parsed) {
        parser.parseDynamic(n, loading);
      }
    }
  },

  shouldLoadNode: function(node) {
    return (node.nodeType === 1) && matches.call(node,
        importer.loadSelectorsForNode(node));
  },

  shouldParseNode: function(node) {
    return (node.nodeType === 1) && matches.call(node,
        parser.parseSelectorsForNode(node));
  }

};

// let the dynamic element helper tie into the import observer.
importer.observer.addCallback = dynamic.added.bind(dynamic);

// x-plat matches
var matches = HTMLElement.prototype.matches ||
    HTMLElement.prototype.matchesSelector ||
    HTMLElement.prototype.webkitMatchesSelector ||
    HTMLElement.prototype.mozMatchesSelector ||
    HTMLElement.prototype.msMatchesSelector;

});
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
(function(scope){

// imports
var initializeModules = scope.initializeModules;
var isIE = scope.isIE;

/*
NOTE: Even when native HTMLImports exists, the following api is available by
loading the polyfill. This provides api compatibility where the polyfill
cannot be "correct":

  * `document._currentScript`
  * `HTMLImportsLoaded` event
  * `HTMLImports.whenReady(callback)
*/
if (scope.useNative) {
  return;
}

// Initialize polyfill modules. Note, polyfill modules are loaded but not
// executed; this is a convenient way to control which modules run when
// the polyfill is required and allows the polyfill to load even when it's
// not needed.
initializeModules();

// imports
var rootDocument = scope.rootDocument;

/*
  Bootstrap the imports machine.
*/
function bootstrap() {
  window.HTMLImports.importer.bootDocument(rootDocument);
}

// TODO(sorvell): SD polyfill does *not* generate mutations for nodes added
// by the parser. For this reason, we must wait until the dom exists to
// bootstrap.
if (document.readyState === 'complete' ||
    (document.readyState === 'interactive' && !window.attachEvent)) {
  bootstrap();
} else {
  document.addEventListener('DOMContentLoaded', bootstrap);
}

})(window.HTMLImports);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope) {

  'use strict';

  var forceShady = scope.flags.shadydom;
  if (forceShady) {
    window.ShadyDOM = window.ShadyDOM || {};
    ShadyDOM.force = forceShady;
  }

  var forceCE = scope.flags.register || scope.flags.ce;
  if (forceCE && window.customElements) {
    customElements.forcePolyfill = forceCE;
  }

})(window.WebComponents);
/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function l(a){if(!/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a)||-1!==t.indexOf(a))return Error("The element name '"+a+"' is not valid.")}function m(a,b,e,d){var c=g();a=e?n.call(a,b,e):n.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,d);c.b(a);return a}
function p(a,b,e,d){b=b.toLowerCase();var c=a.getAttribute(b);d.call(a,b,e);1==a.__$CE_upgraded&&(d=g().a.get(a.localName),e=d.A,(d=d.i)&&0<=e.indexOf(b)&&(e=a.getAttribute(b),e!==c&&d.call(a,b,c,e,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var t="annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ");c.prototype.L=function(a,b){function e(a){var b=f[a];if(void 0!==b&&"function"!==typeof b)throw Error(c+
" '"+a+"' is not a Function");return b}if("function"!==typeof b)throw new TypeError("constructor must be a Constructor");var d=l(a);if(d)throw d;if(this.a.has(a))throw Error("An element with name '"+a+"' is already defined");if(this.j.has(b))throw Error("Definition failed for '"+a+"': The constructor is already used.");var c=a,f=b.prototype;if("object"!==typeof f)throw new TypeError("Definition failed for '"+a+"': constructor.prototype must be an object");var d=e("connectedCallback"),g=e("disconnectedCallback"),
k=e("attributeChangedCallback");this.a.set(c,{name:a,localName:c,constructor:b,v:d,w:g,i:k,A:k&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=l(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var e,d=new Promise(function(a){e=a}),b={N:d,resolve:e};this.h.set(a,b);return d};c.prototype.g=
function(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,
{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var e=a[b];if("childList"===e.type){var d=e.removedNodes;this.c(e.addedNodes);this.H(d)}}};c.prototype.c=function(a,b){b=b||new Set;for(var e=0;e<a.length;e++){var d=a[e];if(d.nodeType===Node.ELEMENT_NODE){this.J(d);
d=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(d.currentNode,b);while(d.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var e=this.a.get(a.localName);if(e){a.__$CE_upgraded||this.u(a,e,!0);var d;if(d=a.__$CE_upgraded&&!a.__$CE_attached)a:{d=a;do{if(d.__$CE_attached||d.nodeType===Node.DOCUMENT_NODE){d=!0;break a}d=d.parentNode||d.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&d.host}while(d);d=!1}d&&(a.__$CE_attached=!0,e.v&&e.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,
b);"LINK"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(" ").indexOf("import")&&this.B(a,b)}};c.prototype.B=function(a,b){var e=a.import;if(e)b.has(e)||(b.add(e),e.__$CE_observer||this.b(e),this.c(e.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var d=this,c=function(){a.removeEventListener("load",c);a.import.__$CE_observer||d.b(a.import);d.c(a.import.childNodes)};a.addEventListener("load",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var e=a[b];if(e.nodeType===Node.ELEMENT_NODE){this.b(e);
e=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do{var d=e.currentNode;if(d.__$CE_upgraded&&d.__$CE_attached){d.__$CE_attached=!1;var c=this.a.get(d.localName);c&&c.w&&c.w.call(d)}}while(e.nextNode())}}};c.prototype.u=function(a,b,e){a.__proto__=b.constructor.prototype;e&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));e=b.A;if((b=b.i)&&0<e.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:e});for(var d=0;d<e.length;d++){var c=e[d];if(a.hasAttribute(c)){var f=
a.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var c=a[b];if("attributes"===c.type){var d=c.target,f=this.a.get(d.localName),g=c.attributeName,h=c.oldValue,k=d.getAttribute(g);k!==h&&f.i.call(d,g,h,k,c.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;
c.prototype._addImport=c.prototype.B;var q=h.HTMLElement;c.prototype.nativeHTMLElement=q;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),m(f,a,void 0,!1);throw Error("Unknown constructor. Did you call customElements.define()?");};h.HTMLElement.prototype=q.prototype;var n=f.createElement;f.createElement=function(a,b){return m(f,a,b,!0)};var u=f.createElementNS;f.createElementNS=function(a,b){return"http://www.w3.org/1999/xhtml"===
a?f.createElement(b):u.call(f,a,b)};var r=Element.prototype.attachShadow;r&&Object.defineProperty(Element.prototype,"attachShadow",{value:function(a){a=r.call(this,a);g().b(a);return a}});var v=f.importNode;f.importNode=function(a,b){a=v.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var w=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){p(this,a,b,w)};var x=Element.prototype.removeAttribute;Element.prototype.removeAttribute=function(a){p(this,
a,null,x)};Object.defineProperty(window,"customElements",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();

//# sourceMappingURL=custom-elements.min.js.map
(function () {
'use strict';

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var settings = window.ShadyDOM || {};

settings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);

settings.inUse = settings.force || !settings.hasNativeShadowDOM;

function isShadyRoot(obj) {
  return Boolean(obj.__localName === 'ShadyRoot');
}

var p = Element.prototype;
var matches = p.matches || p.matchesSelector ||
  p.mozMatchesSelector || p.msMatchesSelector ||
  p.oMatchesSelector || p.webkitMatchesSelector;

function matchesSelector(element, selector) {
  return matches.call(element, selector);
}

function copyOwnProperty(name, source, target) {
  var pd = Object.getOwnPropertyDescriptor(source, name);
  if (pd) {
    Object.defineProperty(target, name, pd);
  }
}

function extend(target, source) {
  if (target && source) {
    var n$ = Object.getOwnPropertyNames(source);
    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {
      copyOwnProperty(n, source, target);
    }
  }
  return target || source;
}

function extendAll(target) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  for (var i=0; i < sources.length; i++) {
    extend(target, sources[i]);
  }
  return target;
}

function mixin(target, source) {
  for (var i in source) {
    target[i] = source[i];
  }
  return target;
}

var setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}

function patchPrototype(obj, mixin) {
  var proto = Object.getPrototypeOf(obj);
  if (!proto.hasOwnProperty('__patchProto')) {
    var patchProto = Object.create(proto);
    patchProto.__sourceProto = proto;
    extend(patchProto, mixin);
    proto.__patchProto = patchProto;
  }
  setPrototypeOf(obj, proto.__patchProto);
}



var common = {};

// TODO(sorvell): actually rely on a real Promise polyfill...
var promish;
if (window.Promise) {
  promish = Promise.resolve();
} else {
  promish = {
    then: function(cb) {
      var twiddle = document.createTextNode('');
      var observer = new MutationObserver(function() {
        observer.disconnect();
        cb();
      });
      observer.observe(twiddle, {characterData: true});
    }
  }
}

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;

var ArraySplice = {

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,
                              old, oldStart, oldEnd) {
    var this$1 = this;

    // "Deletion" columns
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (var j = 0; j < columnCount; j++)
      distances[0][j] = j;

    for (var i$1 = 1; i$1 < rowCount; i$1++) {
      for (var j$1 = 1; j$1 < columnCount; j$1++) {
        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))
          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];
        else {
          var north = distances[i$1 - 1][j$1] + 1;
          var west = distances[i$1][j$1 - 1] + 1;
          distances[i$1][j$1] = north < west ? north : west;
        }
      }
    }

    return distances;
  },

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min;
      if (west < north)
        min = west < northWest ? west : northWest;
      else
        min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  },

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   */
  calcSplices: function calcSplices(current, currentStart, currentEnd,
                        old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var splice;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0)
      prefixCount = this.sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length)
      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
      return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd)
        splice.removed.push(old[oldStart++]);

      return [ splice ];
    } else if (oldStart == oldEnd)
      return [ newSplice(currentStart, [], currentEnd - currentStart) ];

    var ops = this.spliceOperationsFromEditDistances(
        this.calcEditDistances(current, currentStart, currentEnd,
                               old, oldStart, oldEnd));

    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch(ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice)
            splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice)
            splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice)
            splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  },

  sharedPrefix: function sharedPrefix(current, old, searchLength) {
    var this$1 = this;

    for (var i = 0; i < searchLength; i++)
      if (!this$1.equals(current[i], old[i]))
        return i;
    return searchLength;
  },

  sharedSuffix: function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && this.equals(current[--index1], old[--index2]))
      count++;

    return count;
  },

  calculateSplices: function calculateSplices$1(current, previous) {
    return this.calcSplices(current, 0, current.length, previous, 0,
                            previous.length);
  },

  equals: function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

};

var calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// TODO(sorvell): circular (patch loads tree and tree loads patch)
// for now this is stuck on `utils`
//import {patchNode} from './patch'
// native add/remove
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;

/**
 * `tree` is a dom manipulation library used by ShadyDom to
 * manipulate composed and logical trees.
 */
var tree = {

  // sad but faster than slice...
  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {
    var copy=[], i=0;
    for (var n=parent.firstChild; n; n=n.nextSibling) {
      copy[i++] = n;
    }
    return copy;
  },

  arrayCopyChildren: function arrayCopyChildren(parent) {
    var copy=[], i=0;
    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {
      copy[i++] = n;
    }
    return copy;
  },

  arrayCopy: function arrayCopy(a$) {
    var l = a$.length;
    var copy = new Array(l);
    for (var i=0; i < l; i++) {
      copy[i] = a$[i];
    }
    return copy;
  },

  saveChildNodes: function saveChildNodes(node) {
    tree.Logical.saveChildNodes(node);
    if (!tree.Composed.hasParentNode(node)) {
      tree.Composed.saveComposedData(node);
      //tree.Composed.saveParentNode(node);
    }
    tree.Composed.saveChildNodes(node);
  }

};

tree.Logical = {

  hasParentNode: function hasParentNode(node) {
    return Boolean(node.__dom && node.__dom.parentNode);
  },

  hasChildNodes: function hasChildNodes(node) {
    return Boolean(node.__dom && node.__dom.childNodes !== undefined);
  },

  getChildNodes: function getChildNodes(node) {
    // note: we're distinguishing here between undefined and false-y:
    // hasChildNodes uses undefined check to see if this element has logical
    // children; the false-y check indicates whether or not we should rebuild
    // the cached childNodes array.
    return this.hasChildNodes(node) ? this._getChildNodes(node) :
      tree.Composed.getChildNodes(node);
  },

  _getChildNodes: function _getChildNodes(node) {
    if (!node.__dom.childNodes) {
      node.__dom.childNodes = [];
      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {
        node.__dom.childNodes.push(n);
      }
    }
    return node.__dom.childNodes;
  },

  // NOTE: __dom can be created under 2 conditions: (1) an element has a
  // logical tree, or (2) an element is in a logical tree. In case (1), the
  // element will store firstChild/lastChild, and in case (2), the element
  // will store parentNode, nextSibling, previousSibling. This means that
  // the mere existence of __dom is not enough to know if the requested
  // logical data is available and instead we do an explicit undefined check.
  getParentNode: function getParentNode(node) {
    return node.__dom && node.__dom.parentNode !== undefined ?
      node.__dom.parentNode : tree.Composed.getParentNode(node);
  },

  getFirstChild: function getFirstChild(node) {
    return node.__dom && node.__dom.firstChild !== undefined ?
      node.__dom.firstChild : tree.Composed.getFirstChild(node);
  },

  getLastChild: function getLastChild(node) {
    return node.__dom && node.__dom.lastChild  !== undefined ?
      node.__dom.lastChild : tree.Composed.getLastChild(node);
  },

  getNextSibling: function getNextSibling(node) {
    return node.__dom && node.__dom.nextSibling  !== undefined ?
      node.__dom.nextSibling : tree.Composed.getNextSibling(node);
  },

  getPreviousSibling: function getPreviousSibling(node) {
    return node.__dom && node.__dom.previousSibling  !== undefined ?
      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);
  },

  getFirstElementChild: function getFirstElementChild(node) {
    return node.__dom && node.__dom.firstChild !== undefined ?
      this._getFirstElementChild(node) :
      tree.Composed.getFirstElementChild(node);
  },

  _getFirstElementChild: function _getFirstElementChild(node) {
    var n = node.__dom.firstChild;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.nextSibling;
    }
    return n;
  },

  getLastElementChild: function getLastElementChild(node) {
    return node.__dom && node.__dom.lastChild !== undefined ?
      this._getLastElementChild(node) :
      tree.Composed.getLastElementChild(node);
  },

  _getLastElementChild: function _getLastElementChild(node) {
    var n = node.__dom.lastChild;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.previousSibling;
    }
    return n;
  },

  getNextElementSibling: function getNextElementSibling(node) {
    return node.__dom && node.__dom.nextSibling !== undefined ?
      this._getNextElementSibling(node) :
      tree.Composed.getNextElementSibling(node);
  },

  _getNextElementSibling: function _getNextElementSibling(node) {
    var this$1 = this;

    var n = node.__dom.nextSibling;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = this$1.getNextSibling(n);
    }
    return n;
  },

  getPreviousElementSibling: function getPreviousElementSibling(node) {
    return node.__dom && node.__dom.previousSibling !== undefined ?
      this._getPreviousElementSibling(node) :
      tree.Composed.getPreviousElementSibling(node);
  },

  _getPreviousElementSibling: function _getPreviousElementSibling(node) {
    var this$1 = this;

    var n = node.__dom.previousSibling;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = this$1.getPreviousSibling(n);
    }
    return n;
  },

  // Capture the list of light children. It's important to do this before we
  // start transforming the DOM into "rendered" state.
  // Children may be added to this list dynamically. It will be treated as the
  // source of truth for the light children of the element. This element's
  // actual children will be treated as the rendered state once this function
  // has been called.
  saveChildNodes: function saveChildNodes$1(node) {
    if (!this.hasChildNodes(node)) {
      node.__dom = node.__dom || {};
      node.__dom.firstChild = node.firstChild;
      node.__dom.lastChild = node.lastChild;
      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);
      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {
        n.__dom = n.__dom || {};
        n.__dom.parentNode = node;
        n.__dom.nextSibling = c$[i+1] || null;
        n.__dom.previousSibling = c$[i-1] || null;
        common.patchNode(n);
      }
    }
  },

  // TODO(sorvell): may need to patch saveChildNodes iff the tree has
  // already been distributed.
  // NOTE: ensure `node` is patched...
  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {
    var this$1 = this;

    container.__dom.childNodes = null;
    // handle document fragments
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var c$ = tree.arrayCopyChildNodes(node);
      for (var i=0; i < c$.length; i++) {
        this$1._linkNode(c$[i], container, ref_node);
      }
      // cleanup logical dom in doc fragment.
      node.__dom = node.__dom || {};
      node.__dom.firstChild = node.__dom.lastChild = null;
      node.__dom.childNodes = null;
    } else {
      this._linkNode(node, container, ref_node);
    }
  },

  _linkNode: function _linkNode(node, container, ref_node) {
    common.patchNode(node);
    ref_node = ref_node || null;
    node.__dom = node.__dom || {};
    container.__dom = container.__dom || {};
    if (ref_node) {
      ref_node.__dom = ref_node.__dom || {};
    }
    // update ref_node.previousSibling <-> node
    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :
      container.__dom.lastChild;
    if (node.__dom.previousSibling) {
      node.__dom.previousSibling.__dom.nextSibling = node;
    }
    // update node <-> ref_node
    node.__dom.nextSibling = ref_node;
    if (node.__dom.nextSibling) {
      node.__dom.nextSibling.__dom.previousSibling = node;
    }
    // update node <-> container
    node.__dom.parentNode = container;
    if (ref_node) {
      if (ref_node === container.__dom.firstChild) {
        container.__dom.firstChild = node;
      }
    } else {
      container.__dom.lastChild = node;
      if (!container.__dom.firstChild) {
        container.__dom.firstChild = node;
      }
    }
    // remove caching of childNodes
    container.__dom.childNodes = null;
  },

  recordRemoveChild: function recordRemoveChild(node, container) {
    node.__dom = node.__dom || {};
    container.__dom = container.__dom || {};
    if (node === container.__dom.firstChild) {
      container.__dom.firstChild = node.__dom.nextSibling;
    }
    if (node === container.__dom.lastChild) {
      container.__dom.lastChild = node.__dom.previousSibling;
    }
    var p = node.__dom.previousSibling;
    var n = node.__dom.nextSibling;
    if (p) {
      p.__dom = p.__dom || {};
      p.__dom.nextSibling = n;
    }
    if (n) {
      n.__dom = n.__dom || {};
      n.__dom.previousSibling = p;
    }
    // When an element is removed, logical data is no longer tracked.
    // Explicitly set `undefined` here to indicate this. This is disginguished
    // from `null` which is set if info is null.
    node.__dom.parentNode = node.__dom.previousSibling =
      node.__dom.nextSibling = null;
    // remove caching of childNodes
    container.__dom.childNodes = null;
  }

}


// TODO(sorvell): composed tree manipulation is made available
// (1) to maninpulate the composed tree, and (2) to track changes
// to the tree for optional patching pluggability.
tree.Composed = {

  hasParentNode: function hasParentNode$1(node) {
    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);
  },

  hasChildNodes: function hasChildNodes$1(node) {
    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);
  },

  getChildNodes: function getChildNodes$1(node) {
    return this.hasChildNodes(node) ? this._getChildNodes(node) :
      (!node.__patched && tree.arrayCopy(node.childNodes));
  },

  _getChildNodes: function _getChildNodes$1(node) {
    if (!node.__dom.$childNodes) {
      node.__dom.$childNodes = [];
      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {
        node.__dom.$childNodes.push(n);
      }
    }
    return node.__dom.$childNodes;
  },

  getComposedChildNodes: function getComposedChildNodes(node) {
    return node.__dom.$childNodes;
  },

  getParentNode: function getParentNode$1(node) {
    return this.hasParentNode(node) ? node.__dom.$parentNode :
      (!node.__patched && node.parentNode);
  },

  getFirstChild: function getFirstChild$1(node) {
    return node.__patched ? node.__dom.$firstChild : node.firstChild;
  },

  getLastChild: function getLastChild$1(node) {
    return node.__patched ? node.__dom.$lastChild : node.lastChild;
  },

  getNextSibling: function getNextSibling$1(node) {
    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;
  },

  getPreviousSibling: function getPreviousSibling$1(node) {
    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;
  },

  getFirstElementChild: function getFirstElementChild$1(node) {
    return node.__patched ? this._getFirstElementChild(node) :
      node.firstElementChild;
  },

  _getFirstElementChild: function _getFirstElementChild$1(node) {
    var n = node.__dom.$firstChild;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.$nextSibling;
    }
    return n;
  },

  getLastElementChild: function getLastElementChild$1(node) {
    return node.__patched ? this._getLastElementChild(node) :
      node.lastElementChild;
  },

  _getLastElementChild: function _getLastElementChild$1(node) {
    var n = node.__dom.$lastChild;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.$previousSibling;
    }
    return n;
  },

  getNextElementSibling: function getNextElementSibling$1(node) {
    return node.__patched ? this._getNextElementSibling(node) :
      node.nextElementSibling;
  },

  _getNextElementSibling: function _getNextElementSibling$1(node) {
    var this$1 = this;

    var n = node.__dom.$nextSibling;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = this$1.getNextSibling(n);
    }
    return n;
  },

  getPreviousElementSibling: function getPreviousElementSibling$1(node) {
    return node.__patched ? this._getPreviousElementSibling(node) :
      node.previousElementSibling;
  },

  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {
    var this$1 = this;

    var n = node.__dom.$previousSibling;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = this$1.getPreviousSibling(n);
    }
    return n;
  },

  saveChildNodes: function saveChildNodes$2(node) {
    var this$1 = this;

    if (!this.hasChildNodes(node)) {
      node.__dom = node.__dom || {};
      node.__dom.$firstChild = node.firstChild;
      node.__dom.$lastChild = node.lastChild;
      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);
      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {
        this$1.saveComposedData(n);
      }
    }
  },

  saveComposedData: function saveComposedData(node) {
    node.__dom = node.__dom || {};
    if (node.__dom.$parentNode === undefined) {
      node.__dom.$parentNode = node.parentNode;
    }
    if (node.__dom.$nextSibling === undefined) {
      node.__dom.$nextSibling = node.nextSibling;
    }
    if (node.__dom.$previousSibling === undefined) {
      node.__dom.$previousSibling = node.previousSibling;
    }
  },

  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {
    var this$1 = this;

    container.__dom.$childNodes = null;
    // handle document fragments
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      // TODO(sorvell): remember this for patching:
      // the act of setting this info can affect patched nodes
      // getters; therefore capture childNodes before patching.
      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {
        this$1._linkNode(n, container, ref_node);
      }
    } else {
      this._linkNode(node, container, ref_node);
    }
  },

  _linkNode: function _linkNode$1(node, container, ref_node) {
    node.__dom = node.__dom || {};
    container.__dom = container.__dom || {};
    if (ref_node) {
      ref_node.__dom = ref_node.__dom || {};
    }
    // update ref_node.previousSibling <-> node
    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :
      container.__dom.$lastChild;
    if (node.__dom.$previousSibling) {
      node.__dom.$previousSibling.__dom.$nextSibling = node;
    }
    // update node <-> ref_node
    node.__dom.$nextSibling = ref_node;
    if (node.__dom.$nextSibling) {
      node.__dom.$nextSibling.__dom.$previousSibling = node;
    }
    // update node <-> container
    node.__dom.$parentNode = container;
    if (ref_node) {
      if (ref_node === container.__dom.$firstChild) {
        container.__dom.$firstChild = node;
      }
    } else {
      container.__dom.$lastChild = node;
      if (!container.__dom.$firstChild) {
        container.__dom.$firstChild = node;
      }
    }
    // remove caching of childNodes
    container.__dom.$childNodes = null;
  },

  recordRemoveChild: function recordRemoveChild$1(node, container) {
    node.__dom = node.__dom || {};
    container.__dom = container.__dom || {};
    if (node === container.__dom.$firstChild) {
      container.__dom.$firstChild = node.__dom.$nextSibling;
    }
    if (node === container.__dom.$lastChild) {
      container.__dom.$lastChild = node.__dom.$previousSibling;
    }
    var p = node.__dom.$previousSibling;
    var n = node.__dom.$nextSibling;
    if (p) {
      p.__dom = p.__dom || {};
      p.__dom.$nextSibling = n;
    }
    if (n) {
      n.__dom = n.__dom || {};
      n.__dom.$previousSibling = p;
    }
    node.__dom.$parentNode = node.__dom.$previousSibling =
      node.__dom.$nextSibling = null;
    // remove caching of childNodes
    container.__dom.$childNodes = null;
  },

  clearChildNodes: function clearChildNodes(node) {
    var this$1 = this;

    var c$ = this.getChildNodes(node);
    for (var i=0, c; i < c$.length; i++) {
      c = c$[i];
      this$1.recordRemoveChild(c, node);
      nativeRemoveChild.call(node, c)
    }
  },

  saveParentNode: function saveParentNode(node) {
    node.__dom = node.__dom || {};
    node.__dom.$parentNode = node.parentNode;
  },

  insertBefore: function insertBefore(parentNode, newChild, refChild) {
    this.saveChildNodes(parentNode);
    // remove from current location.
    this._addChild(parentNode, newChild, refChild);
    return nativeInsertBefore.call(parentNode, newChild, refChild || null);
  },

  appendChild: function appendChild(parentNode, newChild) {
    this.saveChildNodes(parentNode);
    this._addChild(parentNode, newChild);
    return nativeAppendChild.call(parentNode, newChild);
  },

  removeChild: function removeChild(parentNode, node) {
    var currentParent = this.getParentNode(node);
    this.saveChildNodes(parentNode);
    this._removeChild(parentNode, node);
    if (currentParent === parentNode) {
      return nativeRemoveChild.call(parentNode, node);
    }
  },

  _addChild: function _addChild(parentNode, newChild, refChild) {
    var this$1 = this;

    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);
    var oldParent = this.getParentNode(newChild);
    if (oldParent) {
      this._removeChild(oldParent, newChild);
    }
    if (isFrag) {
      var c$ = this.getChildNodes(newChild);
      for (var i=0; i < c$.length; i++) {
        var c = c$[i];
        // unlink document fragment children
        this$1._removeChild(newChild, c);
        this$1.recordInsertBefore(c, parentNode, refChild);
      }
    } else {
      this.recordInsertBefore(newChild, parentNode, refChild);
    }
  },

  _removeChild: function _removeChild(parentNode, node) {
    this.recordRemoveChild(node, parentNode);
  }

};

// for testing...
var descriptors = {};
function getNativeProperty(element, property) {
  if (!descriptors[property]) {
    descriptors[property] = Object.getOwnPropertyDescriptor(
      HTMLElement.prototype, property) ||
    Object.getOwnPropertyDescriptor(
      Element.prototype, property) ||
    Object.getOwnPropertyDescriptor(
      Node.prototype, property);
  }
  return descriptors[property].get.call(element);
}

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// NOTE: normalize event contruction where necessary (IE11)
var NormalizedEvent = typeof Event === 'function' ? Event :
  function(inType, params) {
    params = params || {};
    var e = document.createEvent('Event');
    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
    return e;
  };

var Distributor = (function () {
  function anonymous(root) {
    this.root = root;
    this.insertionPointTag = 'slot';
  }

  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {
    return this.root.querySelectorAll(this.insertionPointTag);
  };

  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {
    return Boolean(this.root._insertionPoints &&
      this.root._insertionPoints.length);
  };

  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {
    return node.localName && node.localName == this.insertionPointTag;
  };

  anonymous.prototype.distribute = function distribute () {
    if (this.hasInsertionPoint()) {
      return this.distributePool(this.root, this.collectPool());
    }
    return [];
  };

  // Gather the pool of nodes that should be distributed. We will combine
  // these with the "content root" to arrive at the composed tree.
  anonymous.prototype.collectPool = function collectPool () {
    return tree.arrayCopy(
      tree.Logical.getChildNodes(this.root.host));
  };

  // perform "logical" distribution; note, no actual dom is moved here,
  // instead elements are distributed into storage
  // array where applicable.
  anonymous.prototype.distributePool = function distributePool (node, pool) {
    var this$1 = this;

    var dirtyRoots = [];
    var p$ = this.root._insertionPoints;
    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {
      this$1.distributeInsertionPoint(p, pool);
      // provoke redistribution on insertion point parents
      // must do this on all candidate hosts since distribution in this
      // scope invalidates their distribution.
      // only get logical parent.
      var parent = tree.Logical.getParentNode(p);
      if (parent && parent.shadyRoot &&
          this$1.hasInsertionPoint(parent.shadyRoot)) {
        dirtyRoots.push(parent.shadyRoot);
      }
    }
    for (var i$1=0; i$1 < pool.length; i$1++) {
      var p$1 = pool[i$1];
      if (p$1) {
        p$1._assignedSlot = undefined;
        // remove undistributed elements from physical dom.
        var parent$1 = tree.Composed.getParentNode(p$1);
        if (parent$1) {
          tree.Composed.removeChild(parent$1, p$1);
        }
      }
    }
    return dirtyRoots;
  };

  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {
    var this$1 = this;

    var prevAssignedNodes = insertionPoint._assignedNodes;
    if (prevAssignedNodes) {
      this.clearAssignedSlots(insertionPoint, true);
    }
    insertionPoint._assignedNodes = [];
    var needsSlotChange = false;
    // distribute nodes from the pool that this selector matches
    var anyDistributed = false;
    for (var i=0, l=pool.length, node; i < l; i++) {
      node=pool[i];
      // skip nodes that were already used
      if (!node) {
        continue;
      }
      // distribute this node if it matches
      if (this$1.matchesInsertionPoint(node, insertionPoint)) {
        if (node.__prevAssignedSlot != insertionPoint) {
          needsSlotChange = true;
        }
        this$1.distributeNodeInto(node, insertionPoint)
        // remove this node from the pool
        pool[i] = undefined;
        // since at least one node matched, we won't need fallback content
        anyDistributed = true;
      }
    }
    // Fallback content if nothing was distributed here
    if (!anyDistributed) {
      var children = tree.Logical.getChildNodes(insertionPoint);
      for (var j = 0, node$1; j < children.length; j++) {
        node$1 = children[j];
        if (node$1.__prevAssignedSlot != insertionPoint) {
          needsSlotChange = true;
        }
        this$1.distributeNodeInto(node$1, insertionPoint);
      }
    }
    // we're already dirty if a node was newly added to the slot
    // and we're also dirty if the assigned count decreased.
    if (prevAssignedNodes) {
      // TODO(sorvell): the tracking of previously assigned slots
      // could instead by done with a Set and then we could
      // avoid needing to iterate here to clear the info.
      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {
        prevAssignedNodes[i$1].__prevAssignedSlot = null;
      }
      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {
        needsSlotChange = true;
      }
    }
    this.setDistributedNodesOnInsertionPoint(insertionPoint);
    if (needsSlotChange) {
      this._fireSlotChange(insertionPoint);
    }
  };

  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {
    var n$ = slot._assignedNodes;
    if (n$) {
      for (var i=0; i < n$.length; i++) {
        var n = n$[i];
        if (savePrevious) {
          n.__prevAssignedSlot = n._assignedSlot;
        }
        // only clear if it was previously set to this slot;
        // this helps ensure that if the node has otherwise been distributed
        // ignore it.
        if (n._assignedSlot === slot) {
          n._assignedSlot = null;
        }
      }
    }
  };

  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {
    var slotName = insertionPoint.getAttribute('name');
    slotName = slotName ? slotName.trim() : '';
    var slot = node.getAttribute && node.getAttribute('slot');
    slot = slot ? slot.trim() : '';
    return (slot == slotName);
  };

  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {
    insertionPoint._assignedNodes.push(child);
    child._assignedSlot = insertionPoint;
  };

  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {
    var this$1 = this;

    var n$ = insertionPoint._assignedNodes;
    insertionPoint._distributedNodes = [];
    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {
      if (this$1.isInsertionPoint(n)) {
        var d$ = n._distributedNodes;
        if (d$) {
          for (var j=0; j < d$.length; j++) {
            insertionPoint._distributedNodes.push(d$[j]);
          }
        }
      } else {
        insertionPoint._distributedNodes.push(n$[i]);
      }
    }
  };

  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {
    // NOTE: cannot bubble correctly here so not setting bubbles: true
    // Safari tech preview does not bubble but chrome does
    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)
    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));
    if (insertionPoint._assignedSlot) {
      this._fireSlotChange(insertionPoint._assignedSlot);
    }
  };

  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {
    return !(insertionPoint._assignedSlot);
  };

  return anonymous;
}())

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
  Implements a pared down version of ShadowDOM's scoping, which is easy to
  polyfill across browsers.
*/
var ShadyRoot = function ShadyRoot(host) {
  if (!host) {
    throw 'Must provide a host';
  }
  // NOTE: this strange construction is necessary because
  // DocumentFragment cannot be subclassed on older browsers.
  var frag = document.createDocumentFragment();
  frag.__proto__ = ShadyFragmentMixin;
  frag._init(host);
  return frag;
};

var ShadyMixin = {

  _init: function _init(host) {
    // NOTE: set a fake local name so this element can be
    // distinguished from a DocumentFragment when patching.
    // FF doesn't allow this to be `localName`
    this.__localName = 'ShadyRoot';
    // root <=> host
    host.shadyRoot = this;
    this.host = host;
    // logical dom setup
    tree.Logical.saveChildNodes(host);
    tree.Logical.saveChildNodes(this);
    // state flags
    this._clean = true;
    this._hasRendered = false;
    this._distributor = new Distributor(this);
    this.update();
  },

  // async render the "top" distributor (this is all that is needed to
  // distribute this host).
  update: function update() {
    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.
    // Then, in `render`, the top most (in the distribution tree) "dirty" root should be rendered.
    var distributionRoot = this._findDistributionRoot(this.host);
    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);
    if (distributionRoot._clean) {
      distributionRoot._clean = false;
      enqueue(function() {
        distributionRoot.render();
      });
    }
  },

  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)
  // this should only return a shadowRoot.
  // returns the host that's the top of this host's distribution tree
  _findDistributionRoot: function _findDistributionRoot(element) {
    var root = element.shadyRoot;
    while (element && this._elementNeedsDistribution(element)) {
      root = element.getRootNode();
      element = root && root.host;
    }
    return root;
  },

  // Return true if a host's children includes
  // an insertion point that selects selectively
  _elementNeedsDistribution: function _elementNeedsDistribution(element) {
    var this$1 = this;

    var c$ = tree.Logical.getChildNodes(element);
    for (var i=0, c; i < c$.length; i++) {
      c = c$[i];
      if (this$1._distributor.isInsertionPoint(c)) {
        return element.getRootNode();
      }
    }
  },

  render: function render() {
    if (!this._clean) {
      this._clean = true;
      if (!this._skipUpdateInsertionPoints) {
        this.updateInsertionPoints();
      } else if (!this._hasRendered) {
        this._insertionPoints = [];
      }
      this._skipUpdateInsertionPoints = false;
      // TODO(sorvell): previous ShadyDom had a fast path here
      // that would avoid distribution for initial render if
      // no insertion points exist. We cannot currently do this because
      // it relies on elements being in the physical shadowRoot element
      // so that native methods will be used. The current append code
      // simply provokes distribution in this case and does not put the
      // nodes in the shadowRoot. This could be done but we'll need to
      // consider if the special processing is worth the perf gain.
      // if (!this._hasRendered && !this._insertionPoints.length) {
      //   tree.Composed.clearChildNodes(this.host);
      //   tree.Composed.appendChild(this.host, this);
      // } else {
      // logical
      this.distribute();
      // physical
      this.compose();
      this._hasRendered = true;
    }
  },

  forceRender: function forceRender() {
    this._clean = false;
    this.render();
  },

  distribute: function distribute() {
    var dirtyRoots = this._distributor.distribute();
    for (var i=0; i<dirtyRoots.length; i++) {
      dirtyRoots[i].forceRender();
    }
  },

  updateInsertionPoints: function updateInsertionPoints() {
    var this$1 = this;

    var i$ = this.__insertionPoints;
    // if any insertion points have been removed, clear their distribution info
    if (i$) {
      for (var i=0, c; i < i$.length; i++) {
        c = i$[i];
        if (c.getRootNode() !== this$1) {
          this$1._distributor.clearAssignedSlots(c);
        }
      }
    }
    i$ = this._insertionPoints = this._distributor.getInsertionPoints();
    // ensure insertionPoints's and their parents have logical dom info.
    // save logical tree info
    // a. for shadyRoot
    // b. for insertion points (fallback)
    // c. for parents of insertion points
    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {
      c$1 = i$[i$1];
      tree.Logical.saveChildNodes(c$1);
      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));
    }
  },

  get _insertionPoints() {
    if (!this.__insertionPoints) {
      this.updateInsertionPoints();
    }
    return this.__insertionPoints || (this.__insertionPoints = []);
  },

  set _insertionPoints(insertionPoints) {
    this.__insertionPoints = insertionPoints;
  },

  hasInsertionPoint: function hasInsertionPoint() {
    return this._distributor.hasInsertionPoint();
  },

  compose: function compose() {
    // compose self
    // note: it's important to mark this clean before distribution
    // so that attachment that provokes additional distribution (e.g.
    // adding something to your parentNode) works
    this._composeTree();
    // TODO(sorvell): See fast paths here in Polymer v1
    // (these seem unnecessary)
  },

  // Reify dom such that it is at its correct rendering position
  // based on logical distribution.
  _composeTree: function _composeTree() {
    var this$1 = this;

    this._updateChildNodes(this.host, this._composeNode(this.host));
    var p$ = this._insertionPoints || [];
    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {
      parent = tree.Logical.getParentNode(p);
      if ((parent !== this$1.host) && (parent !== this$1)) {
        this$1._updateChildNodes(parent, this$1._composeNode(parent));
      }
    }
  },

  // Returns the list of nodes which should be rendered inside `node`.
  _composeNode: function _composeNode(node) {
    var this$1 = this;

    var children = [];
    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);
    for (var i = 0; i < c$.length; i++) {
      var child = c$[i];
      if (this$1._distributor.isInsertionPoint(child)) {
        var distributedNodes = child._distributedNodes ||
          (child._distributedNodes = []);
        for (var j = 0; j < distributedNodes.length; j++) {
          var distributedNode = distributedNodes[j];
          if (this$1.isFinalDestination(child, distributedNode)) {
            children.push(distributedNode);
          }
        }
      } else {
        children.push(child);
      }
    }
    return children;
  },

  isFinalDestination: function isFinalDestination(insertionPoint, node) {
    return this._distributor.isFinalDestination(
      insertionPoint, node);
  },

  // Ensures that the rendered node list inside `container` is `children`.
  _updateChildNodes: function _updateChildNodes(container, children) {
    var composed = tree.Composed.getChildNodes(container);
    var splices = calculateSplices(children, composed);
    // process removals
    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
        // check if the node is still where we expect it is before trying
        // to remove it; this can happen if we move a node and
        // then schedule its previous host for distribution resulting in
        // the node being removed here.
        if (tree.Composed.getParentNode(n) === container) {
          tree.Composed.removeChild(container, n);
        }
        composed.splice(s.index + d, 1);
      }
      d -= s.addedCount;
    }
    // process adds
    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare
      next = composed[s$1.index];
      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {
        n$1 = children[j$1];
        tree.Composed.insertBefore(container, n$1, next);
        // TODO(sorvell): is this splice strictly needed?
        composed.splice(j$1, 0, n$1);
      }
    }
  },

  getInsertionPointTag: function getInsertionPointTag() {
    return this._distributor.insertionPointTag;
  }

}

var ShadyFragmentMixin = Object.create(DocumentFragment.prototype);
extend(ShadyFragmentMixin, ShadyMixin);

// let needsUpgrade = window.CustomElements && !CustomElements.useNative;

// function upgradeLogicalChildren(children) {
//   if (needsUpgrade && children) {
//     for (let i=0; i < children.length; i++) {
//       CustomElements.upgrade(children[i]);
//     }
//   }
// }

// render enqueuer/flusher
var customElements = window.customElements;
var flushList = [];
var scheduled;
var flushCount = 0;
var flushMax = 100;
function enqueue(callback) {
  if (!scheduled) {
    scheduled = true;
    promish.then(flush$1);
  }
  flushList.push(callback);
}

function flush$1() {
  scheduled = false;
  flushCount++;
  while (flushList.length) {
    flushList.shift()();
  }
  if (customElements && customElements.flush) {
    customElements.flush();
  }
  // continue flushing after elements are upgraded...
  var isFlushedMaxed = (flushCount > flushMax);
  if (flushList.length && !isFlushedMaxed) {
      flush$1();
  }
  flushCount = 0;
  if (isFlushedMaxed) {
    throw new Error('Loop detected in ShadyDOM distribution, aborting.')
  }
}

flush$1.list = flushList;

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// Cribbed from ShadowDOM polyfill
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28
/////////////////////////////////////////////////////////////////////////////
// innerHTML and outerHTML

// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;

function escapeReplace(c) {
  switch (c) {
    case '&':
      return '&amp;';
    case '<':
      return '&lt;';
    case '>':
      return '&gt;';
    case '"':
      return '&quot;';
    case '\u00A0':
      return '&nbsp;';
  }
}

function escapeAttr(s) {
  return s.replace(escapeAttrRegExp, escapeReplace);
}

function escapeData(s) {
  return s.replace(escapeDataRegExp, escapeReplace);
}

function makeSet(arr) {
  var set = {};
  for (var i = 0; i < arr.length; i++) {
    set[arr[i]] = true;
  }
  return set;
}

// http://www.whatwg.org/specs/web-apps/current-work/#void-elements
var voidElements = makeSet([
  'area',
  'base',
  'br',
  'col',
  'command',
  'embed',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'track',
  'wbr'
]);

var plaintextParents = makeSet([
  'style',
  'script',
  'xmp',
  'iframe',
  'noembed',
  'noframes',
  'plaintext',
  'noscript'
]);

function getOuterHTML(node, parentNode, composed) {
  switch (node.nodeType) {
    case Node.ELEMENT_NODE: {
      var tagName = node.localName;
      var s = '<' + tagName;
      var attrs = node.attributes;
      for (var i = 0, attr; (attr = attrs[i]); i++) {
        s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
      }
      s += '>';
      if (voidElements[tagName]) {
        return s;
      }
      return s + getInnerHTML(node, composed) + '</' + tagName + '>';
    }
    case Node.TEXT_NODE: {
      var data = node.data;
      if (parentNode && plaintextParents[parentNode.localName]) {
        return data;
      }
      return escapeData(data);
    }
    case Node.COMMENT_NODE: {
      return '\x3c!--' + node.data + '--\x3e';
    }
    default: {
      window.console.error(node);
      throw new Error('not implemented');
    }
  }
}

function getInnerHTML(node, composed) {
  if (node.localName === 'template') {
    node = node.content;
  }
  var s = '';
  var c$ = composed ? composed(node) : node.childNodes;
  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {
    s += getOuterHTML(child, node, composed);
  }
  return s;
}

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var mixinImpl = {

  // Try to add node. Record logical info, track insertion points, perform
  // distribution iff needed. Return true if the add is handled.
  addNode: function addNode(container, node, ref_node) {
    var ownerRoot = this.ownerShadyRootForNode(container);
    if (ownerRoot) {
      // optimization: special insertion point tracking
      if (node.__noInsertionPoint && ownerRoot._clean) {
        ownerRoot._skipUpdateInsertionPoints = true;
      }
      // note: we always need to see if an insertion point is added
      // since this saves logical tree info; however, invalidation state
      // needs
      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);
      // invalidate insertion points IFF not already invalid!
      if (ipAdded) {
        ownerRoot._skipUpdateInsertionPoints = false;
      }
    }
    if (tree.Logical.hasChildNodes(container)) {
      tree.Logical.recordInsertBefore(node, container, ref_node);
    }
    // if not distributing and not adding to host, do a fast path addition
    var handled = this._maybeDistribute(node, container, ownerRoot) ||
      container.shadyRoot;
    return handled;
  },

  // Try to remove node: update logical info and perform distribution iff
  // needed. Return true if the removal has been handled.
  // note that it's possible for both the node's host and its parent
  // to require distribution... both cases are handled here.
  removeNode: function removeNode(node) {
    // important that we want to do this only if the node has a logical parent
    var logicalParent = tree.Logical.hasParentNode(node) &&
      tree.Logical.getParentNode(node);
    var distributed;
    var ownerRoot = this.ownerShadyRootForNode(node);
    if (logicalParent) {
      // distribute node's parent iff needed
      distributed = this.maybeDistributeParent(node);
      tree.Logical.recordRemoveChild(node, logicalParent);
      // remove node from root and distribute it iff needed
      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||
        logicalParent.localName === ownerRoot.getInsertionPointTag())) {
        ownerRoot._skipUpdateInsertionPoints = false;
        ownerRoot.update();
      }
    }
    this._removeOwnerShadyRoot(node);
    return distributed;
  },


  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {
    var observer = node.__dom && node.__dom.observer;
    if (observer) {
      if (addedNode) {
        observer.addedNodes.push(addedNode);
      }
      if (removedNode) {
        observer.removedNodes.push(removedNode);
      }
      observer.schedule();
    }
  },

  removeNodeFromParent: function removeNodeFromParent(node, parent) {
    if (parent) {
      this._scheduleObserver(parent, null, node);
      this.removeNode(node);
    } else {
      this._removeOwnerShadyRoot(node);
    }
  },

  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {
    return Boolean(node.__ownerShadyRoot !== undefined);
  },

  getRootNode: function getRootNode$1(node) {
    if (!node || !node.nodeType) {
      return;
    }
    var root = node.__ownerShadyRoot;
    if (root === undefined) {
      if (isShadyRoot(node)) {
        root = node;
      } else {
        var parent = tree.Logical.getParentNode(node);
        root = parent ? this.getRootNode(parent) : node;
      }
      // memo-ize result for performance but only memo-ize
      // result if node is in the document. This avoids a problem where a root
      // can be cached while an element is inside a fragment.
      // If this happens and we cache the result, the value can become stale
      // because for perf we avoid processing the subtree of added fragments.
      if (document.documentElement.contains(node)) {
        node.__ownerShadyRoot = root;
      }
    }
    return root;
  },

  ownerShadyRootForNode: function ownerShadyRootForNode(node) {
    var root = this.getRootNode(node);
    if (isShadyRoot(root)) {
      return root;
    }
  },

  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {
    // TODO(sorvell): technically we should check non-fragment nodes for
    // <content> children but since this case is assumed to be exceedingly
    // rare, we avoid the cost and will address with some specific api
    // when the need arises.  For now, the user must call
    // distributeContent(true), which updates insertion points manually
    // and forces distribution.
    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';
    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&
      !node.__noInsertionPoint &&
      insertionPointTag && node.querySelector(insertionPointTag);
    var wrappedContent = fragContent &&
      (tree.Logical.getParentNode(fragContent).nodeType !==
      Node.DOCUMENT_FRAGMENT_NODE);
    var hasContent = fragContent || (node.localName === insertionPointTag);
    // There are 3 possible cases where a distribution may need to occur:
    // 1. <content> being inserted (the host of the shady root where
    //    content is inserted needs distribution)
    // 2. children being inserted into parent with a shady root (parent
    //    needs distribution)
    // 3. container is an insertionPoint
    if (hasContent || (container.localName === insertionPointTag)) {
      if (ownerRoot) {
        // note, insertion point list update is handled after node
        // mutations are complete
        ownerRoot.update();
      }
    }
    var needsDist = this._nodeNeedsDistribution(container);
    if (needsDist) {
      container.shadyRoot.update();
    }
    // Return true when distribution will fully handle the composition
    // Note that if a content was being inserted that was wrapped by a node,
    // and the parent does not need distribution, return false to allow
    // the nodes to be added directly, after which children may be
    // distributed and composed into the wrapping node(s)
    return needsDist || (hasContent && !wrappedContent);
  },

  /* note: parent argument is required since node may have an out
  of date parent at this point; returns true if a <content> is being added */
  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {
    var this$1 = this;

    var added;
    var insertionPointTag = root.getInsertionPointTag();
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&
      !node.__noInsertionPoint) {
      var c$ = node.querySelectorAll(insertionPointTag);
      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {
        np = tree.Logical.getParentNode(n);
        // don't allow node's parent to be fragment itself
        if (np === node) {
          np = parent;
        }
        na = this$1._maybeAddInsertionPoint(n, np, root);
        added = added || na;
      }
    } else if (node.localName === insertionPointTag) {
      tree.Logical.saveChildNodes(parent);
      tree.Logical.saveChildNodes(node);
      added = true;
    }
    return added;
  },

  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {
    return node && node.shadyRoot &&
      node.shadyRoot.hasInsertionPoint();
  },

  _removeDistributedChildren: function _removeDistributedChildren(root, container) {
    var this$1 = this;

    var hostNeedsDist;
    var ip$ = root._insertionPoints;
    for (var i=0; i<ip$.length; i++) {
      var insertionPoint = ip$[i];
      if (this$1._contains(container, insertionPoint)) {
        var dc$ = insertionPoint.assignedNodes({flatten: true});
        for (var j=0; j<dc$.length; j++) {
          hostNeedsDist = true;
          var node = dc$[j];
          var parent = tree.Composed.getParentNode(node);
          if (parent) {
            tree.Composed.removeChild(parent, node);
          }
        }
      }
    }
    return hostNeedsDist;
  },

  _contains: function _contains(container, node) {
    while (node) {
      if (node == container) {
        return true;
      }
      node = tree.Logical.getParentNode(node);
    }
  },

  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {
    var this$1 = this;

    // optimization: only reset the tree if node is actually in a root
    if (this._hasCachedOwnerRoot(node)) {
      var c$ = tree.Logical.getChildNodes(node);
      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {
        this$1._removeOwnerShadyRoot(n);
      }
    }
    node.__ownerShadyRoot = undefined;
  },

  // TODO(sorvell): This will fail if distribution that affects this
  // question is pending; this is expected to be exceedingly rare, but if
  // the issue comes up, we can force a flush in this case.
  firstComposedNode: function firstComposedNode(insertionPoint) {
    var n$ = insertionPoint.assignedNodes({flatten: true});
    var root = this.getRootNode(insertionPoint);
    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
      // means that we're composed to this spot.
      if (root.isFinalDestination(insertionPoint, n)) {
        return n;
      }
    }
  },

  clearNode: function clearNode(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  },

  maybeDistributeParent: function maybeDistributeParent(node) {
    var parent = tree.Logical.getParentNode(node);
    if (this._nodeNeedsDistribution(parent)) {
      parent.shadyRoot.update();
      return true;
    }
  },

  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {
    if (name === 'slot') {
      this.maybeDistributeParent(node);
    } else if (node.localName === 'slot' && name === 'name') {
      var root = this.ownerShadyRootForNode(node);
      if (root) {
        root.update();
      }
    }
  },

  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,
  // but it's also generally useful to recurse through the element tree
  // and is used by Polymer's styling system.
  query: function query(node, matcher, halter) {
    var list = [];
    this._queryElements(tree.Logical.getChildNodes(node), matcher,
      halter, list);
    return list;
  },

  _queryElements: function _queryElements(elements, matcher, halter, list) {
    var this$1 = this;

    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {
      if (c.nodeType === Node.ELEMENT_NODE &&
          this$1._queryElement(c, matcher, halter, list)) {
        return true;
      }
    }
  },

  _queryElement: function _queryElement(node, matcher, halter, list) {
    var result = matcher(node);
    if (result) {
      list.push(node);
    }
    if (halter && halter(result)) {
      return result;
    }
    this._queryElements(tree.Logical.getChildNodes(node), matcher,
      halter, list);
  },

  activeElementForNode: function activeElementForNode(node) {
    var this$1 = this;

    var active = document.activeElement;
    if (!active) {
      return null;
    }
    var isShadyRoot$$1 = !!(isShadyRoot(node));
    if (node !== document) {
      // If this node isn't a document or shady root, then it doesn't have
      // an active element.
      if (!isShadyRoot$$1) {
        return null;
      }
      // If this shady root's host is the active element or the active
      // element is not a descendant of the host (in the composed tree),
      // then it doesn't have an active element.
      if (node.host === active ||
          !node.host.contains(active)) {
        return null;
      }
    }
    // This node is either the document or a shady root of which the active
    // element is a (composed) descendant of its host; iterate upwards to
    // find the active element's most shallow host within it.
    var activeRoot = this.ownerShadyRootForNode(active);
    while (activeRoot && activeRoot !== node) {
      active = activeRoot.host;
      activeRoot = this$1.ownerShadyRootForNode(active);
    }
    if (node === document) {
      // This node is the document, so activeRoot should be null.
      return activeRoot ? null : active;
    } else {
      // This node is a non-document shady root, and it should be
      // activeRoot.
      return activeRoot === node ? active : null;
    }
  }

};

var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
var nativeSetAttribute$1 = Element.prototype.setAttribute;
var nativeRemoveAttribute = Element.prototype.removeAttribute;

var setAttribute = function(attr, value) {
  // avoid scoping elements in non-main document to avoid template documents
  if (window.ShadyCSS && attr === 'class' && this.ownerDocument === document) {
    window.ShadyCSS.setElementClass(this, value);
  } else {
    nativeSetAttribute$1.call(this, attr, value);
  }
}

var NodeMixin = {};

Object.defineProperties(NodeMixin, {

  parentElement: {
    get: function get() {
      return tree.Logical.getParentNode(this);
    },
    configurable: true
  },

  parentNode: {
    get: function get$1() {
      return tree.Logical.getParentNode(this);
    },
    configurable: true
  },

  nextSibling: {
    get: function get$2() {
      return tree.Logical.getNextSibling(this);
    },
    configurable: true
  },

  previousSibling: {
    get: function get$3() {
      return tree.Logical.getPreviousSibling(this);
    },
    configurable: true
  },

  nextElementSibling: {
    get: function get$4() {
      return tree.Logical.getNextElementSibling(this);
    },
    configurable: true
  },

  previousElementSibling: {
    get: function get$5() {
      return tree.Logical.getPreviousElementSibling(this);
    },
    configurable: true
  },

  assignedSlot: {
    get: function get$6() {
      return this._assignedSlot;
    },
    configurable: true
  }
});

var FragmentMixin = {

  appendChild: function appendChild(node) {
    return this.insertBefore(node);
  },

  // cases in which we may not be able to just do standard native call
  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot
  // has an insertion point)
  // 2. container is a shadyRoot (don't distribute, instead set
  // container to container.host.
  // 3. node is <content> (host of container needs distribution)
  insertBefore: function insertBefore(node, ref_node) {
    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {
      throw Error('The ref_node to be inserted before is not a child ' +
        'of this node');
    }
    // remove node from its current position iff it's in a tree.
    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
      var parent = tree.Logical.getParentNode(node);
      mixinImpl.removeNodeFromParent(node, parent);
    }
    if (!mixinImpl.addNode(this, node, ref_node)) {
      if (ref_node) {
        // if ref_node is an insertion point replace with first distributed node
        var root = mixinImpl.ownerShadyRootForNode(ref_node);
        if (root) {
          ref_node = ref_node.localName === root.getInsertionPointTag() ?
            mixinImpl.firstComposedNode(ref_node) : ref_node;
        }
      }
      // if adding to a shadyRoot, add to host instead
      var container = isShadyRoot(this) ?
        this.host : this;
      if (ref_node) {
        tree.Composed.insertBefore(container, node, ref_node);
      } else {
        tree.Composed.appendChild(container, node);
      }
    }
    mixinImpl._scheduleObserver(this, node);
    return node;
  },

  /**
    Removes the given `node` from the element's `lightChildren`.
    This method also performs dom composition.
  */
  removeChild: function removeChild(node) {
    if (tree.Logical.getParentNode(node) !== this) {
      throw Error('The node to be removed is not a child of this node: ' +
        node);
    }
    if (!mixinImpl.removeNode(node)) {
      // if removing from a shadyRoot, remove form host instead
      var container = isShadyRoot(this) ?
        this.host :
        this;
      // not guaranteed to physically be in container; e.g.
      // undistributed nodes.
      var parent = tree.Composed.getParentNode(node);
      if (container === parent) {
        tree.Composed.removeChild(container, node);
      }
    }
    mixinImpl._scheduleObserver(this, null, node);
    return node;
  },

  replaceChild: function replaceChild(node, ref_node) {
    this.insertBefore(node, ref_node);
    this.removeChild(ref_node);
    return node;
  },

  // TODO(sorvell): consider doing native QSA and filtering results.
  querySelector: function querySelector(selector) {
    // match selector and halt on first result.
    var result = mixinImpl.query(this, function(n) {
      return matchesSelector(n, selector);
    }, function(n) {
      return Boolean(n);
    })[0];
    return result || null;
  },

  querySelectorAll: function querySelectorAll(selector) {
    return mixinImpl.query(this, function(n) {
      return matchesSelector(n, selector);
    });
  },

  cloneNode: function cloneNode(deep) {
    if (this.localName == 'template') {
      return nativeCloneNode.call(this, deep);
    } else {
      var n = nativeCloneNode.call(this, false);
      if (deep) {
        var c$ = this.childNodes;
        for (var i=0, nc; i < c$.length; i++) {
          nc = c$[i].cloneNode(true);
          n.appendChild(nc);
        }
      }
      return n;
    }
  },

  importNode: function importNode(externalNode, deep) {
    // for convenience use this node's ownerDoc if the node isn't a document
    var doc = this instanceof Document ? this :
      this.ownerDocument;
    var n = nativeImportNode.call(doc, externalNode, false);
    if (deep) {
      var c$ = tree.Logical.getChildNodes(externalNode);
      common.patchNode(n);
      for (var i=0, nc; i < c$.length; i++) {
        nc = doc.importNode(c$[i], true);
        n.appendChild(nc);
      }
    }
    return n;
  }
};

Object.defineProperties(FragmentMixin, {

  childNodes: {
    get: function get$7() {
      var c$ = tree.Logical.getChildNodes(this);
      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);
    },
    configurable: true
  },

  children: {
    get: function get$8() {
      if (tree.Logical.hasChildNodes(this)) {
        return Array.prototype.filter.call(this.childNodes, function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      } else {
        return tree.arrayCopyChildren(this);
      }
    },
    configurable: true
  },

  firstChild: {
    get: function get$9() {
      return tree.Logical.getFirstChild(this);
    },
    configurable: true
  },

  lastChild: {
    get: function get$10() {
      return tree.Logical.getLastChild(this);
    },
    configurable: true
  },

  firstElementChild: {
    get: function get$11() {
      return tree.Logical.getFirstElementChild(this);
    },
    configurable: true
  },

  lastElementChild: {
    get: function get$12() {
      return tree.Logical.getLastElementChild(this);
    },
    configurable: true
  },

  // TODO(srovell): strictly speaking fragments do not have textContent
  // or innerHTML but ShadowRoots do and are not easily distinguishable.
  // textContent / innerHTML
  textContent: {
    get: function get$13() {
      if (this.childNodes) {
        var tc = [];
        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }
      return '';
    },
    set: function set(text) {
      mixinImpl.clearNode(this);
      if (text) {
        this.appendChild(document.createTextNode(text));
      }
    },
    configurable: true
  },

  innerHTML: {
    get: function get$14() {
      return getInnerHTML(this);
    },
    set: function set$1(text) {
      var this$1 = this;

      mixinImpl.clearNode(this);
      var d = document.createElement('div');
      d.innerHTML = text;
      // here, appendChild may move nodes async so we cannot rely
      // on node position when copying
      var c$ = tree.arrayCopyChildNodes(d);
      for (var i=0; i < c$.length; i++) {
        this$1.appendChild(c$[i]);
      }
    },
    configurable: true
  }

});

var ElementMixin = {

  // TODO(sorvell): should only exist on <slot>
  assignedNodes: function assignedNodes(options) {
    return (options && options.flatten ? this._distributedNodes :
      this._assignedNodes) || [];
  },


  setAttribute: function setAttribute$1(name, value) {
    setAttribute.call(this, name, value);
    mixinImpl.maybeDistributeAttributeChange(this, name);
  },

  removeAttribute: function removeAttribute(name) {
    nativeRemoveAttribute.call(this, name);
    mixinImpl.maybeDistributeAttributeChange(this, name);
  }

};

Object.defineProperties(ElementMixin, {

  shadowRoot: {
    get: function get$15() {
      return this.shadyRoot;
    }
  },

  slot: {
    get: function get$16() {
      return this.getAttribute('slot');
    },
    set: function set$2(value) {
      this.setAttribute('slot', value);
    }
  }

});

var activeElementDescriptor = {
  get: function get$17() {
    return mixinImpl.activeElementForNode(this);
  }
}

var ActiveElementMixin = {};
Object.defineProperties(ActiveElementMixin, {
  activeElement: activeElementDescriptor
});

var UnderActiveElementMixin = {};
Object.defineProperties(UnderActiveElementMixin, {
  _activeElement: activeElementDescriptor
});

var Mixins = {

  Node: extendAll({__patched: 'Node'}, NodeMixin),

  Fragment: extendAll({__patched: 'Fragment'},
    NodeMixin, FragmentMixin, ActiveElementMixin),

  Element: extendAll({__patched: 'Element'},
    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),

  // Note: activeElement cannot be patched on document!
  Document: extendAll({__patched: 'Document'},
    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)

};

var getRootNode = function(node) {
  return mixinImpl.getRootNode(node);
}

function filterMutations(mutations, target) {
  var targetRootNode = getRootNode(target);
  return mutations.map(function(mutation) {
    var mutationInScope = (targetRootNode === getRootNode(mutation.target));
    if (mutationInScope && mutation.addedNodes) {
      var nodes = Array.from(mutation.addedNodes).filter(function(n) {
        return (targetRootNode === getRootNode(n));
      });
      if (nodes.length) {
        mutation = Object.create(mutation);
        Object.defineProperty(mutation, 'addedNodes', {
          value: nodes,
          configurable: true
        });
        return mutation;
      }
    } else if (mutationInScope) {
      return mutation;
    }
  }).filter(function(m) { return m});
}

// const promise = Promise.resolve();

var AsyncObserver = function AsyncObserver() {
  this._scheduled = false;
  this.addedNodes = [];
  this.removedNodes = [];
  this.callbacks = new Set();
};

AsyncObserver.prototype.schedule = function schedule () {
    var this$1 = this;

  if (!this._scheduled) {
    this._scheduled = true;
    promish.then(function () {
      this$1.flush();
    });
  }
};

AsyncObserver.prototype.flush = function flush () {
  if (this._scheduled) {
    this._scheduled = false;
    var mutations = this.takeRecords();
    if (mutations.length) {
      this.callbacks.forEach(function(cb) {
        cb(mutations);
      });
    }
  }
};

AsyncObserver.prototype.takeRecords = function takeRecords () {
  if (this.addedNodes.length || this.removedNodes.length) {
    var mutations = [{
      addedNodes: this.addedNodes,
      removedNodes: this.removedNodes
    }];
    this.addedNodes = [];
    this.removedNodes = [];
    return mutations;
  }
  return [];
};

var getComposedInnerHTML = function(node) {
  if (common.isNodePatched(node)) {
    return getInnerHTML(node, function(n) {
      return tree.Composed.getChildNodes(n);
    })
  } else {
    return node.innerHTML;
  }
}

var getComposedChildNodes$1 = function(node) {
  return common.isNodePatched(node) ?
    tree.Composed.getChildNodes(node) :
    node.childNodes;
}

// TODO(sorvell): consider instead polyfilling MutationObserver
// directly so that users do not have to fork their code.
// Supporting the entire api may be challenging: e.g. filtering out
// removed nodes in the wrong scope and seeing non-distributing
// subtree child mutations.
var observeChildren = function(node, callback) {
  common.patchNode(node);
  if (!node.__dom.observer) {
    node.__dom.observer = new AsyncObserver();
  }
  node.__dom.observer.callbacks.add(callback);
  var observer = node.__dom.observer;
  return {
    _callback: callback,
    _observer: observer,
    _node: node,
    takeRecords: function takeRecords() {
      return observer.takeRecords()
    }
  };
}

var unobserveChildren = function(handle) {
  var observer = handle && handle._observer;
  if (observer) {
    observer.callbacks.delete(handle._callback);
    if (!observer.callbacks.size) {
      handle._node.__dom.observer = null;
    }
  }
}

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Patches elements that interacts with ShadyDOM
 * such that tree traversal and mutation apis act like they would under
 * ShadowDOM.
 *
 * This import enables seemless interaction with ShadyDOM powered
 * custom elements, enabling better interoperation with 3rd party code,
 * libraries, and frameworks that use DOM tree manipulation apis.
 */

var patchedCount = 0;

var log = false;

var patchImpl = {

  canPatchNode: function(node) {
    switch (node) {
      case document.head:
      case document.documentElement:
        return false;
      default:
        return true;
    }
  },

  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(
    window.Node.prototype, 'textContent')),

  patch: function(node) {
    patchedCount++;
    log && window.console.warn('patch node', node);
    if (this.hasPrototypeDescriptors) {
      patchPrototype(node, this.mixinForObject(node));
    } else {
      window.console.warn('Patching instance rather than prototype', node);
      extend(node, this.mixinForObject(node));
    }
  },

  mixinForObject: function(obj) {
    switch (obj.nodeType) {
      case Node.ELEMENT_NODE:
        return Mixins.Element;
      case Node.DOCUMENT_FRAGMENT_NODE:
        return Mixins.Fragment;
      case Node.DOCUMENT_NODE:
        return Mixins.Document;
      case Node.TEXT_NODE:
      case Node.COMMENT_NODE:
        return Mixins.Node;
    }
  },

  unpatch: function(obj) {
    if (obj.__sourceProto) {
      obj.__proto__ = obj.__sourceProto;

    }
    // TODO(sorvell): implement unpatching for non-proto patchable browsers
  }

};

function patchNode(node) {
  if (!settings.inUse) {
    return;
  }
  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {
    tree.saveChildNodes(node);
    patchImpl.patch(node);
  }
}

function canUnpatchNode() {
  return Boolean(patchImpl.hasPrototypeDescriptors);
}

function unpatchNode(node) {
  patchImpl.unpatch(node);
}

function isNodePatched(node) {
  return Boolean(node.__patched);
}

// TODO(sorvell): fake export
common.patchNode = patchNode;
common.canUnpatchNode = canUnpatchNode;
common.isNodePatched = isNodePatched;

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var origAddEventListener = Element.prototype.addEventListener;
var origRemoveEventListener = Element.prototype.removeEventListener;

// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937
var alwaysComposed = {
  blur: true,
  focus: true,
  focusin: true,
  focusout: true,
  click: true,
  dblclick: true,
  mousedown: true,
  mouseenter: true,
  mouseleave: true,
  mousemove: true,
  mouseout: true,
  mouseover: true,
  mouseup: true,
  wheel: true,
  beforeinput: true,
  input: true,
  keydown: true,
  keyup: true,
  compositionstart: true,
  compositionupdate: true,
  compositionend: true,
  touchstart: true,
  touchend: true,
  touchmove: true,
  touchcancel: true,
  pointerover: true,
  pointerenter: true,
  pointerdown: true,
  pointermove: true,
  pointerup: true,
  pointercancel: true,
  pointerout: true,
  pointerleave: true,
  gotpointercapture: true,
  lostpointercapture: true,
  dragstart: true,
  drag: true,
  dragenter: true,
  dragleave: true,
  dragover: true,
  drop: true,
  dragend: true,
  DOMActivate: true,
  DOMFocusIn: true,
  DOMFocusOut: true,
  keypress: true
};

function pathComposer(startNode, composed) {
  var composedPath = [];
  var current = startNode;
  var startRoot = startNode === window ? window : startNode.getRootNode();
  while (current) {
    composedPath.push(current);
    if (current.assignedSlot) {
      current = current.assignedSlot;
    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {
      current = current.host;
    } else {
      current = current.parentNode;
    }
  }
  // event composedPath includes window when startNode's ownerRoot is document
  if (composedPath[composedPath.length - 1] === document) {
    composedPath.push(window);
  }
  return composedPath;
}

function retarget(refNode, path) {
  if (!isShadyRoot) {
    return refNode;
  }
  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
  // shadow-including inclusive ancestor, return ANCESTOR.
  var refNodePath = pathComposer(refNode, true);
  var p$ = path;
  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
    ancestor = p$[i];
    root = ancestor === window ? window : ancestor.getRootNode();
    if (root !== lastRoot) {
      rootIdx = refNodePath.indexOf(root);
      lastRoot = root;
    }
    if (!isShadyRoot(root) || rootIdx > -1) {
      return ancestor;
    }
  }
}

var EventMixin = {

  __patched: 'Event',

  get composed() {
    if (this.isTrusted && this.__composed === undefined) {
      this.__composed = alwaysComposed[this.type];
    }
    return this.__composed || false;
  },

  composedPath: function composedPath() {
    if (!this.__composedPath) {
      this.__composedPath = pathComposer(this.__target, this.composed);
    }
    return this.__composedPath;
  },

  get target() {
    return retarget(this.currentTarget, this.composedPath());
  },

  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting
  get relatedTarget() {
    if (!this.__relatedTarget) {
      return null;
    }
    if (!this.__relatedTargetComposedPath) {
      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);
    }
    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget
    return retarget(this.currentTarget, this.__relatedTargetComposedPath);
  },
  stopPropagation: function stopPropagation() {
    Event.prototype.stopPropagation.call(this);
    this.__propagationStopped = true;
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    Event.prototype.stopImmediatePropagation.call(this);
    this.__immediatePropagationStopped = true;
    this.__propagationStopped = true;
  }

};

function mixinComposedFlag(Base) {
  // NOTE: avoiding use of `class` here so that transpiled output does not
  // try to do `Base.call` with a dom construtor.
  var klazz = function(type, options) {
    var event = new Base(type, options);
    event.__composed = options && Boolean(options.composed);
    return event;
  }
  // put constructor properties on subclass
  mixin(klazz, Base);
  klazz.prototype = Base.prototype;
  return klazz;
}

var nonBubblingEventsToRetarget = {
  focus: true,
  blur: true
};

function fireHandlers(event, node, phase) {
  var hs = node.__handlers && node.__handlers[event.type] &&
    node.__handlers[event.type][phase];
  if (hs) {
    for (var i = 0, fn; (fn = hs[i]); i++) {
      fn.call(node, event);
      if (event.__immediatePropagationStopped) {
        return;
      }
    }
  }
}

function retargetNonBubblingEvent(e) {
  var path = e.composedPath();
  var node;
  // override `currentTarget` to let patched `target` calculate correctly
  Object.defineProperty(e, 'currentTarget', {
    get: function() {
      return node;
    },
    configurable: true
  });
  for (var i = path.length - 1; i >= 0; i--) {
    node = path[i];
    // capture phase fires all capture handlers
    fireHandlers(e, node, 'capture');
    if (e.__propagationStopped) {
      return;
    }
  }

  // set the event phase to `AT_TARGET` as in spec
  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});

  // the event only needs to be fired when owner roots change when iterating the event path
  // keep track of the last seen owner root
  var lastFiredRoot;
  for (var i$1 = 0; i$1 < path.length; i$1++) {
    node = path[i$1];
    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {
      fireHandlers(e, node, 'bubble');
      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway
      if (node !== window) {
        lastFiredRoot = node.getRootNode();
      }
      if (e.__propagationStopped) {
        return;
      }
    }
  }
}

function addEventListener(type, fn, optionsOrCapture) {
  var this$1 = this;

  if (!fn) {
    return;
  }

  // The callback `fn` might be used for multiple nodes/events. Since we generate
  // a wrapper function, we need to keep track of it when we remove the listener.
  // It's more efficient to store the node/type/options information as Array in
  // `fn` itself rather than the node (we assume that the same callback is used
  // for few nodes at most, whereas a node will likely have many event listeners).
  // NOTE(valdrin) invoking external functions is costly, inline has better perf.
  var capture, once, passive;
  if (typeof optionsOrCapture === 'object') {
    capture = Boolean(optionsOrCapture.capture);
    once = Boolean(optionsOrCapture.once);
    passive = Boolean(optionsOrCapture.passive);
  } else {
    capture = Boolean(optionsOrCapture);
    once = false;
    passive = false;
  }
  if (fn.__eventWrappers) {
    // Stop if the wrapper function has already been created.
    for (var i = 0; i < fn.__eventWrappers.length; i++) {
      if (fn.__eventWrappers[i].node === this$1 &&
          fn.__eventWrappers[i].type === type &&
          fn.__eventWrappers[i].capture === capture &&
          fn.__eventWrappers[i].once === once &&
          fn.__eventWrappers[i].passive === passive) {
        return;
      }
    }
  } else {
    fn.__eventWrappers = [];
  }

  var wrapperFn = function(e) {
    // Support `once` option.
    if (once) {
      this.removeEventListener(type, fn, optionsOrCapture);
    }
    if (!e.__target) {
      e.__target = e.target;
      e.__relatedTarget = e.relatedTarget;
      patchPrototype(e, EventMixin);
    }
    // There are two critera that should stop events from firing on this node
    // 1. the event is not composed and the current node is not in the same root as the target
    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node
    if (e.composed || e.composedPath().indexOf(this) > -1) {
      if (e.eventPhase === Event.BUBBLING_PHASE) {
        if (e.target === e.relatedTarget) {
          e.stopImmediatePropagation();
          return;
        }
      }
      return fn(e);
    }
  };
  // Store the wrapper information.
  fn.__eventWrappers.push({
    node: this,
    type: type,
    capture: capture,
    once: once,
    passive: passive,
    wrapperFn: wrapperFn
  });

  if (nonBubblingEventsToRetarget[type]) {
    this.__handlers = this.__handlers || {};
    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};
    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);
  } else {
    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }
}

function removeEventListener(type, fn, optionsOrCapture) {
  var this$1 = this;

  if (!fn) {
    return;
  }

  // NOTE(valdrin) invoking external functions is costly, inline has better perf.
  var capture, once, passive;
  if (typeof optionsOrCapture === 'object') {
    capture = Boolean(optionsOrCapture.capture);
    once = Boolean(optionsOrCapture.once);
    passive = Boolean(optionsOrCapture.passive);
  } else {
    capture = Boolean(optionsOrCapture);
    once = false;
    passive = false;
  }
  // Search the wrapped function.
  var wrapperFn = undefined;
  if (fn.__eventWrappers) {
    for (var i = 0; i < fn.__eventWrappers.length; i++) {
      if (fn.__eventWrappers[i].node === this$1 &&
          fn.__eventWrappers[i].type === type &&
          fn.__eventWrappers[i].capture === capture &&
          fn.__eventWrappers[i].once === once &&
          fn.__eventWrappers[i].passive === passive) {
        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;
        // Cleanup.
        if (!fn.__eventWrappers.length) {
          fn.__eventWrappers = undefined;
        }
        break;
      }
    }
  }

  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);
  if (wrapperFn && nonBubblingEventsToRetarget[type] &&
      this.__handlers && this.__handlers[type]) {
    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];
    var idx = arr.indexOf(wrapperFn);
    if (idx > -1) {
      arr.splice(idx, 1);
    }
  }
}

function activateFocusEventOverrides() {
  for (var ev in nonBubblingEventsToRetarget) {
    window.addEventListener(ev, function(e) {
      if (!e.__target) {
        e.__target = e.target;
        e.__relatedTarget = e.relatedTarget;
        patchPrototype(e, EventMixin);
        retargetNonBubblingEvent(e);
        e.stopImmediatePropagation();
      }
    }, true);
  }
}


var PatchedEvent = mixinComposedFlag(Event);
var PatchedCustomEvent = mixinComposedFlag(CustomEvent);
var PatchedMouseEvent = mixinComposedFlag(MouseEvent);

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Patches elements that interacts with ShadyDOM
 * such that tree traversal and mutation apis act like they would under
 * ShadowDOM.
 *
 * This import enables seemless interaction with ShadyDOM powered
 * custom elements, enabling better interoperation with 3rd party code,
 * libraries, and frameworks that use DOM tree manipulation apis.
 */

if (settings.inUse) {

  window.ShadyDOM = {
    tree: tree,
    getNativeProperty: getNativeProperty,
    patch: patchNode,
    isPatched: isNodePatched,
    getComposedInnerHTML: getComposedInnerHTML,
    getComposedChildNodes: getComposedChildNodes$1,
    unpatch: unpatchNode,
    canUnpatch: canUnpatchNode,
    isShadyRoot: isShadyRoot,
    enqueue: enqueue,
    flush: flush$1,
    inUse: settings.inUse,
    filterMutations: filterMutations,
    observeChildren: observeChildren,
    unobserveChildren: unobserveChildren
  };

  var createRootAndEnsurePatched = function(node) {
    // TODO(sorvell): need to ensure ancestors are patched but this introduces
    // a timing problem with gathering composed children.
    // (1) currently the child list is crawled and patched when patching occurs
    // (this needs to change)
    // (2) we can only patch when an element has received its parsed children
    // because we cannot detect them when inserted by parser.
    // let ancestor = node;
    // while (ancestor) {
    //   patchNode(ancestor);
    //   ancestor = ancestor.parentNode || ancestor.host;
    // }
    patchNode(node);
    var root = new ShadyRoot(node);
    patchNode(root);
    return root;
  }

  Element.prototype.attachShadow = function() {
    return createRootAndEnsurePatched(this);
  }

  Node.prototype.addEventListener = addEventListener;
  Node.prototype.removeEventListener = removeEventListener;
  Event = PatchedEvent;
  CustomEvent = PatchedCustomEvent;
  MouseEvent = PatchedMouseEvent;
  activateFocusEventOverrides();

  Object.defineProperty(Node.prototype, 'isConnected', {
    get: function get() {
      return document.documentElement.contains(this);
    },
    configurable: true
  });

  Node.prototype.getRootNode = function(options) {
    return getRootNode(this, options);
  }

  Object.defineProperty(Element.prototype, 'slot', {
    get: function get$1() {
      return this.getAttribute('slot');
    },
    set: function set(value) {
      this.setAttribute('slot', value);
    },
    configurable: true
  });

  Object.defineProperty(Node.prototype, 'assignedSlot', {
    get: function get$2() {
      return this._assignedSlot || null;
    },
    configurable: true
  });

  var nativeSetAttribute = Element.prototype.setAttribute;
  Element.prototype.setAttribute = setAttribute;
  // NOTE: expose native setAttribute to allow hooking native method
  // (e.g. this is done in ShadyCSS)
  Element.prototype.__nativeSetAttribute = nativeSetAttribute;

  var classNameDescriptor = {
    get: function get$3() {
      return this.getAttribute('class');
    },
    set: function set$1(value) {
      this.setAttribute('class', value);
    },
    configurable: true
  };

  // Safari 9 `className` is not configurable
  var cn = Object.getOwnPropertyDescriptor(Element.prototype, 'className');
  if (cn && cn.configurable) {
    Object.defineProperty(Element.prototype, 'className', classNameDescriptor);
  } else {
    // on IE `className` is on Element
    var h = window.customElements && window.customElements.nativeHTMLElement ||
      HTMLElement;
    cn = Object.getOwnPropertyDescriptor(h.prototype, 'className');
    if (cn && cn.configurable) {
      Object.defineProperty(h.prototype, 'className', classNameDescriptor);
    }
  }
}

}());

//# sourceMappingURL=shadydom.min.js.map
(function(){'use strict';/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/function e(De){return De=a(De),u(d(De),De)}function a(De){return De.replace(X.comments,'').replace(X.port,'')}function d(De){let ke={start:0,end:De.length},Ue=ke;for(let Ke=0,Xe=De.length;Ke<Xe;Ke++)if(De[Ke]===U){Ue.rules||(Ue.rules=[]);let Ve=Ue,je=Ve.rules[Ve.rules.length-1];Ue={start:Ke+1,parent:Ve,previous:je},Ve.rules.push(Ue)}else De[Ke]===K&&(Ue.end=Ke+1,Ue=Ue.parent||ke);return ke}function u(De,ke){let Ue=ke.substring(De.start,De.end-1);if(De.parsedCssText=De.cssText=Ue.trim(),De.parent){let Xe=De.previous?De.previous.end:De.parent.start;Ue=ke.substring(Xe,De.start-1),Ue=y(Ue),Ue=Ue.replace(X.multipleSpaces,' '),Ue=Ue.substring(Ue.lastIndexOf(';')+1);let Ve=De.parsedSelector=De.selector=Ue.trim();De.atRule=0===Ve.indexOf('@'),De.atRule?0===Ve.indexOf('@media')?De.type=k.MEDIA_RULE:Ve.match(X.keyframesRule)&&(De.type=k.KEYFRAMES_RULE,De.keyframesName=De.selector.split(X.multipleSpaces).pop()):0===Ve.indexOf(V)?De.type=k.MIXIN_RULE:De.type=k.STYLE_RULE}let Ke=De.rules;if(Ke)for(let je,Xe=0,Ve=Ke.length;Xe<Ve&&(je=Ke[Xe]);Xe++)u(je,ke);return De}function y(De){return De.replace(/\\([0-9a-f]{1,6})\s/gi,function(){let ke=arguments[1],Ue=6-ke.length;for(;Ue--;)ke='0'+ke;return'\\'+ke})}function _(De,ke,Ue){Ue=Ue||'';let Ke='';if(De.cssText||De.rules){let Xe=De.rules;if(Xe&&!S(Xe))for(let Be,Ve=0,je=Xe.length;Ve<je&&(Be=Xe[Ve]);Ve++)Ke=_(Be,ke,Ke);else Ke=ke?De.cssText:h(De.cssText),Ke=Ke.trim(),Ke&&(Ke='  '+Ke+'\n')}return Ke&&(De.selector&&(Ue+=De.selector+' '+U+'\n'),Ue+=Ke,De.selector&&(Ue+=K+'\n\n')),Ue}function S(De){return 0===De[0].selector.indexOf(V)}function h(De){return De=g(De),C(De)}function g(De){return De.replace(X.customProp,'').replace(X.mixinProp,'')}function C(De){return De.replace(X.mixinApply,'').replace(X.varApply,'')}function E(De){De&&(B=B&&!De.shimcssproperties,j=j&&!De.shimshadow)}function A(De,ke){return'string'==typeof De&&(De=e(De)),ke&&R(De,ke),_(De,B)}function T(De){return!De.__cssRules&&De.textContent&&(De.__cssRules=e(De.textContent)),De.__cssRules}function N(De){return De.parent&&De.parent.type===k.KEYFRAMES_RULE}function R(De,ke,Ue,Ke){if(De){let Xe=!1;if(Ke&&De.type===k.MEDIA_RULE){let je=De.selector.match(q.MEDIA_MATCH);je&&!window.matchMedia(je[1]).matches&&(Xe=!0)}De.type===k.STYLE_RULE?ke(De):Ue&&De.type===k.KEYFRAMES_RULE?Ue(De):De.type===k.MIXIN_RULE&&(Xe=!0);let Ve=De.rules;if(Ve&&!Xe)for(let Ye,je=0,Be=Ve.length;je<Be&&(Ye=Ve[je]);je++)R(Ye,ke,Ue,Ke)}}function P(De,ke,Ue,Ke){let Xe=O(De,ke);return I(Xe,Ue,Ke)}function I(De,ke,Ue){ke=ke||document.head;let Ke=Ue&&Ue.nextSibling||ke.firstChild;return G=De,ke.insertBefore(De,Ke)}function O(De,ke){let Ue=document.createElement('style');return ke&&Ue.setAttribute('scope',ke),Ue.textContent=De,Ue}function M(De){let ke=document.createComment(' Shady DOM styles for '+De+' '),Ue=G?G.nextSibling:null,Ke=document.head;return Ke.insertBefore(ke,Ue||Ke.firstChild),G=ke,ke}function b(De,ke){let Ue=0;for(let Ke=ke,Xe=De.length;Ke<Xe;Ke++)if('('===De[Ke])Ue++;else if(')'===De[Ke]&&0==--Ue)return Ke;return-1}function w(De,ke){let Ue=De.indexOf('var(');if(-1===Ue)return ke(De,'','','');let Ke=b(De,Ue+3),Xe=De.substring(Ue+4,Ke),Ve=De.substring(0,Ue),je=w(De.substring(Ke+1),ke),Be=Xe.indexOf(',');if(-1===Be)return ke(Ve,Xe.trim(),'',je);let Ye=Xe.substring(0,Be).trim(),Ge=Xe.substring(Be+1).trim();return ke(Ve,Ye,Ge,je)}function L(De,ke){De.__nativeSetAttribute?De.__nativeSetAttribute('class',ke):De.setAttribute('class',ke)}function H(De,ke){let Ue=parseInt(De/32);ke[Ue]=(ke[Ue]||0)|1<<De%32}function F(){we||(we=!0,window.HTMLImports?window.HTMLImports.whenReady(D):'complete'===document.readyState?D():document.addEventListener('readystatechange',()=>{'complete'===document.readyState&&D()}))}function D(){requestAnimationFrame(()=>{(we||be._elementsHaveApplied)&&be.updateStyles(),we=!1})}let k={STYLE_RULE:1,KEYFRAMES_RULE:7,MEDIA_RULE:4,MIXIN_RULE:1e3},U='{',K='}',X={comments:/\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,port:/@import[^;]*;/gim,customProp:/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,mixinProp:/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,mixinApply:/@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,varApply:/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,keyframesRule:/^@[^\s]*keyframes/,multipleSpaces:/\s+/g},V='--',j=!(window.ShadyDOM&&window.ShadyDOM.inUse),B=!navigator.userAgent.match('AppleWebKit/601')&&window.CSS&&CSS.supports&&CSS.supports('box-shadow','0 0 0 var(--foo)'),Y=!1;window.ShadyCSS?E(window.ShadyCSS):window.WebComponents&&E(window.WebComponents.flags);let G=null,q={VAR_ASSIGN:/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,MIXIN_MATCH:/(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,VAR_CONSUMED:/(--[\w-]+)\s*([:,;)]|$)/gi,ANIMATION_MATCH:/(animation\s*:)|(animation-name\s*:)/,MEDIA_MATCH:/@media[^(]*(\([^)]*\))/,IS_VAR:/^--/,BRACKETED:/\{[^}]*\}/g,HOST_PREFIX:'(?:^|[^.#[:])',HOST_SUFFIX:'($|[.:[\\s>+~])'};const W='style-scope';class z{get SCOPE_NAME(){return W}dom(De,ke,Ue){De.__styleScoped?De.__styleScoped=null:this._transformDom(De,ke||'',Ue)}_transformDom(De,ke,Ue){De.nodeType===Node.ELEMENT_NODE&&this.element(De,ke,Ue);let Ke='template'===De.localName?(De.content||De._content).childNodes:De.children||De.childNodes;if(Ke)for(let Xe=0;Xe<Ke.length;Xe++)this._transformDom(Ke[Xe],ke,Ue)}element(De,ke,Ue){if(ke)if(De.classList)Ue?(De.classList.remove(W),De.classList.remove(ke)):(De.classList.add(W),De.classList.add(ke));else if(De.getAttribute){let Ke=De.getAttribute('class');if(!Ue){let Xe=(Ke?Ke+' ':'')+W+' '+ke;L(De,Xe)}else if(Ke){let Xe=Ke.replace(W,'').replace(ke,'');L(De,Xe)}}}elementStyles(De,ke,Ue){let Ke=De.__cssBuild,Xe=j||'shady'===Ke?A(ke,Ue):this.css(ke,De.is,De.extends,Ue)+'\n\n';return Xe.trim()}css(De,ke,Ue,Ke){let Xe=this._calcHostScope(ke,Ue);ke=this._calcElementScope(ke);let Ve=this;return A(De,function(je){je.isScoped||(Ve.rule(je,ke,Xe),je.isScoped=!0),Ke&&Ke(je,ke,Xe)})}_calcElementScope(De){return De?'.'+De:''}_calcHostScope(De,ke){return ke?'[is='+De+']':De}rule(De,ke,Ue){this._transformRule(De,this._transformComplexSelector,ke,Ue)}_transformRule(De,ke,Ue,Ke){De.selector=De.transformedSelector=this._transformRuleCss(De,ke,Ue,Ke)}_transformRuleCss(De,ke,Ue,Ke){let Xe=De.selector.split(Z);if(!N(De))for(let Be,Ve=0,je=Xe.length;Ve<je&&(Be=Xe[Ve]);Ve++)Xe[Ve]=ke.call(this,Be,Ue,Ke);return Xe.join(Z)}_transformComplexSelector(De,ke,Ue){let Ke=!1;return De=De.trim(),De=De.replace($,(Xe,Ve,je)=>`:${Ve}(${je.replace(/\s/g,'')})`),De=De.replace(re,`${te} $1`),De=De.replace(J,(Xe,Ve,je)=>{if(!Ke){let Be=this._transformCompoundSelector(je,Ve,ke,Ue);Ke=Ke||Be.stop,Ve=Be.combinator,je=Be.value}return Ve+je}),De}_transformCompoundSelector(De,ke,Ue,Ke){let Xe=De.indexOf(se);0<=De.indexOf(te)?De=this._transformHostSelector(De,Ke):0!==Xe&&(De=Ue?this._transformSimpleSelector(De,Ue):De);let Ve=!1;0<=Xe&&(ke='',Ve=!0);let je;return Ve&&(je=!0,Ve&&(De=De.replace(oe,(Be,Ye)=>` > ${Ye}`))),De=De.replace(le,(Be,Ye,Ge)=>`[dir="${Ge}"] ${Ye}, ${Ye}[dir="${Ge}"]`),{value:De,combinator:ke,stop:je}}_transformSimpleSelector(De,ke){let Ue=De.split(ae);return Ue[0]+=ke,Ue.join(ae)}_transformHostSelector(De,ke){let Ue=De.match(ne),Ke=Ue&&Ue[2].trim()||'';if(Ke){if(!Ke[0].match(ee)){let Xe=Ke.split(ee)[0];return Xe===ke?Ke:'should_not_match'}return De.replace(ne,function(Xe,Ve,je){return ke+je})}return De.replace(te,ke)}documentRule(De){De.selector=De.parsedSelector,this.normalizeRootSelector(De),this._transformRule(De,this._transformDocumentSelector)}normalizeRootSelector(De){':root'===De.selector&&(De.selector='html')}_transformDocumentSelector(De){return De.match(se)?this._transformComplexSelector(De,Q):this._transformSimpleSelector(De.trim(),Q)}}let $=/:(nth[-\w]+)\(([^)]+)\)/,Q=`:not(.${W})`,Z=',',J=/(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g,ee=/[[.:#*]/,te=':host',se='::slotted',re=/^(::slotted)/,ne=/(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,oe=/(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,le=/(.*):dir\((?:(ltr|rtl))\)/,ae=':';var ie=new z,pe={};const de=Promise.resolve();class me{static get(De){return De.__styleInfo}static set(De,ke){return De.__styleInfo=ke,ke}static invalidate(De){pe[De]&&(pe[De]._applyShimInvalid=!0)}static startValidating(De){const ke=pe[De];ke._validating||(ke._validating=!0,de.then(()=>{ke._applyShimInvalid=!1,ke._validating=!1}))}constructor(De,ke,Ue,Ke,Xe,Ve){this.styleRules=De||null,this.placeholder=ke||null,this.ownStylePropertyNames=Ue||[],this.overrideStyleProperties=null,this.elementName=Ke||'',this.cssBuild=Ve||'',this.typeExtension=Xe||'',this.styleProperties=null,this.scopeSelector=null,this.customStyle=null}}const ue=window.Element.prototype,ye=ue.matches||ue.matchesSelector||ue.mozMatchesSelector||ue.msMatchesSelector||ue.oMatchesSelector||ue.webkitMatchesSelector,_e=navigator.userAgent.match('Trident'),fe='x-scope';class Se{get XSCOPE_NAME(){return fe}decorateStyles(De){let ke=this,Ue={},Ke=[],Xe=0;R(De,function(je){ke.decorateRule(je),je.index=Xe++,ke.collectPropertiesInCssText(je.propertyInfo.cssText,Ue)},function(Be){Ke.push(Be)}),De._keyframes=Ke;let Ve=[];for(let je in Ue)Ve.push(je);return Ve}decorateRule(De){if(De.propertyInfo)return De.propertyInfo;let ke={},Ue={},Ke=this.collectProperties(De,Ue);return Ke&&(ke.properties=Ue,De.rules=null),ke.cssText=this.collectCssText(De),De.propertyInfo=ke,ke}collectProperties(De,ke){let Ue=De.propertyInfo;if(!Ue){let Ke,Xe=q.VAR_ASSIGN,Ve=De.parsedCssText,je,Be;for(;Ke=Xe.exec(Ve);)je=(Ke[2]||Ke[3]).trim(),('inherit'!==je||'unset'!==je)&&(ke[Ke[1].trim()]=je),Be=!0;return Be}else if(Ue.properties)return Object.assign(ke,Ue.properties),!0}collectCssText(De){return this.collectConsumingCssText(De.parsedCssText)}collectConsumingCssText(De){return De.replace(q.BRACKETED,'').replace(q.VAR_ASSIGN,'')}collectPropertiesInCssText(De,ke){for(let Ue;Ue=q.VAR_CONSUMED.exec(De);){let Ke=Ue[1];':'!==Ue[2]&&(ke[Ke]=!0)}}reify(De){let ke=Object.getOwnPropertyNames(De);for(let Ke,Ue=0;Ue<ke.length;Ue++)Ke=ke[Ue],De[Ke]=this.valueForProperty(De[Ke],De)}valueForProperty(De,ke){if(De)if(0<=De.indexOf(';'))De=this.valueForProperties(De,ke);else{let Ue=this;De=w(De,function(Ke,Xe,Ve,je){if(!Xe)return Ke+je;let Be=Ue.valueForProperty(ke[Xe],ke);return Be&&'initial'!==Be?'apply-shim-inherit'===Be&&(Be='inherit'):Be=Ue.valueForProperty(ke[Ve]||Ve,ke)||Ve,Ke+(Be||'')+je})}return De&&De.trim()||''}valueForProperties(De,ke){let Ue=De.split(';');for(let Xe,Ve,Ke=0;Ke<Ue.length;Ke++)if(Xe=Ue[Ke]){if(q.MIXIN_MATCH.lastIndex=0,Ve=q.MIXIN_MATCH.exec(Xe),Ve)Xe=this.valueForProperty(ke[Ve[1]],ke);else{let je=Xe.indexOf(':');if(-1!==je){let Be=Xe.substring(je);Be=Be.trim(),Be=this.valueForProperty(Be,ke)||Be,Xe=Xe.substring(0,je)+Be}}Ue[Ke]=Xe&&Xe.lastIndexOf(';')===Xe.length-1?Xe.slice(0,-1):Xe||''}return Ue.join(';')}applyProperties(De,ke){let Ue='';De.propertyInfo||this.decorateRule(De),De.propertyInfo.cssText&&(Ue=this.valueForProperties(De.propertyInfo.cssText,ke)),De.cssText=Ue}applyKeyframeTransforms(De,ke){let Ue=De.cssText,Ke=De.cssText;if(null==De.hasAnimations&&(De.hasAnimations=q.ANIMATION_MATCH.test(Ue)),De.hasAnimations){let Xe;if(null==De.keyframeNamesToTransform)for(let Ve in De.keyframeNamesToTransform=[],ke)Xe=ke[Ve],Ke=Xe(Ue),Ue!==Ke&&(Ue=Ke,De.keyframeNamesToTransform.push(Ve));else{for(let Ve=0;Ve<De.keyframeNamesToTransform.length;++Ve)Xe=ke[De.keyframeNamesToTransform[Ve]],Ue=Xe(Ue);Ke=Ue}}De.cssText=Ke}propertyDataFromStyles(De,ke){let Ue={},Ke=this,Xe=[];return R(De,function(Ve){Ve.propertyInfo||Ke.decorateRule(Ve);let je=Ve.transformedSelector||Ve.parsedSelector;ke&&Ve.propertyInfo.properties&&je&&ye.call(ke,je)&&(Ke.collectProperties(Ve,Ue),H(Ve.index,Xe))},null,!0),{properties:Ue,key:Xe}}whenHostOrRootRule(De,ke,Ue,Ke){if(ke.propertyInfo||this.decorateRule(ke),!!ke.propertyInfo.properties){let Xe=De.is?ie._calcHostScope(De.is,De.extends):'html',Ve=ke.parsedSelector,je=':host > *'===Ve||'html'===Ve,Be=0===Ve.indexOf(':host')&&!je;if('shady'===Ue&&(je=Ve===Xe+' > *.'+Xe||-1!==Ve.indexOf('html'),Be=!je&&0===Ve.indexOf(Xe)),'shadow'===Ue&&(je=':host > *'===Ve||'html'===Ve,Be=Be&&!je),je||Be){let Ye=Xe;Be&&(j&&!ke.transformedSelector&&(ke.transformedSelector=ie._transformRuleCss(ke,ie._transformComplexSelector,ie._calcElementScope(De.is),Xe)),Ye=ke.transformedSelector||Xe),Ke({selector:Ye,isHost:Be,isRoot:je})}}}hostAndRootPropertiesForScope(De,ke){let Ue={},Ke={},Xe=this,Ve=ke&&ke.__cssBuild;return R(ke,function(je){Xe.whenHostOrRootRule(De,je,Ve,function(Be){let Ye=De._element||De;ye.call(Ye,Be.selector)&&(Be.isHost?Xe.collectProperties(je,Ue):Xe.collectProperties(je,Ke))})},null,!0),{rootProps:Ke,hostProps:Ue}}transformStyles(De,ke,Ue){let Ke=this,Xe=ie._calcHostScope(De.is,De.extends),Ve=De.extends?'\\'+Xe.slice(0,-1)+'\\]':Xe,je=new RegExp(q.HOST_PREFIX+Ve+q.HOST_SUFFIX),Be=me.get(De).styleRules,Ye=this._elementKeyframeTransforms(De,Be,Ue);return ie.elementStyles(De,Be,function(Ge){Ke.applyProperties(Ge,ke),j||N(Ge)||!Ge.cssText||(Ke.applyKeyframeTransforms(Ge,Ye),Ke._scopeSelector(Ge,je,Xe,Ue))})}_elementKeyframeTransforms(De,ke,Ue){let Ke=ke._keyframes,Xe={};if(!j&&Ke)for(let Ve=0,je=Ke[Ve];Ve<Ke.length;je=Ke[++Ve])this._scopeKeyframes(je,Ue),Xe[je.keyframesName]=this._keyframesRuleTransformer(je);return Xe}_keyframesRuleTransformer(De){return function(ke){return ke.replace(De.keyframesNameRx,De.transformedKeyframesName)}}_scopeKeyframes(De,ke){De.keyframesNameRx=new RegExp(De.keyframesName,'g'),De.transformedKeyframesName=De.keyframesName+'-'+ke,De.transformedSelector=De.transformedSelector||De.selector,De.selector=De.transformedSelector.replace(De.keyframesName,De.transformedKeyframesName)}_scopeSelector(De,ke,Ue,Ke){De.transformedSelector=De.transformedSelector||De.selector;let Xe=De.transformedSelector,Ve='.'+Ke,je=Xe.split(',');for(let Ge,Be=0,Ye=je.length;Be<Ye&&(Ge=je[Be]);Be++)je[Be]=Ge.match(ke)?Ge.replace(Ue,Ve):Ve+' '+Ge;De.selector=je.join(',')}applyElementScopeSelector(De,ke,Ue){let Ke=De.getAttribute('class')||'',Xe=Ke;Ue&&(Xe=Ke.replace(new RegExp('\\s*'+fe+'\\s*'+Ue+'\\s*','g'),' ')),Xe+=(Xe?' ':'')+fe+' '+ke,Ke!==Xe&&(De.__nativeSetAttribute?De.__nativeSetAttribute('class',Xe):De.setAttribute('class',Xe))}applyElementStyle(De,ke,Ue,Ke){let Xe=Ke?Ke.textContent||'':this.transformStyles(De,ke,Ue),Ve=me.get(De),je=Ve.customStyle;return je&&!j&&je!==Ke&&(je._useCount--,0>=je._useCount&&je.parentNode&&je.parentNode.removeChild(je)),j?Ve.customStyle?(Ve.customStyle.textContent=Xe,Ke=Ve.customStyle):Xe&&(Ke=P(Xe,Ue,De.shadowRoot,Ve.placeholder)):Ke?!Ke.parentNode&&I(Ke,null,Ve.placeholder):Xe&&(Ke=P(Xe,Ue,null,Ve.placeholder)),Ke&&(Ke._useCount=Ke._useCount||0,Ve.customStyle!=Ke&&Ke._useCount++,Ve.customStyle=Ke),_e&&(Ke.textContent=Ke.textContent),Ke}applyCustomStyle(De,ke){let Ue=T(De),Ke=this;De.textContent=A(Ue,function(Xe){let Ve=Xe.cssText=Xe.parsedCssText;Xe.propertyInfo&&Xe.propertyInfo.cssText&&(Ve=g(Ve),Xe.cssText=Ke.valueForProperties(Ve,ke))})}}var he=new Se;let ge={};const xe=window.customElements;if(xe&&!j){const De=xe.define;xe.define=function(ke,Ue,Ke){return ge[ke]=M(ke),De.call(xe,ke,Ue,Ke)}}let Ce=q.MIXIN_MATCH,Ee=q.VAR_ASSIGN,Ae=/;\s*/m,Te=/^\s*(initial)|(inherit)\s*$/,Ne='_-_';class ve{constructor(){this._map={}}set(De,ke){De=De.trim(),this._map[De]={properties:ke,dependants:{}}}get(De){return De=De.trim(),this._map[De]}}class Re{constructor(){this._currentTemplate=null,this._measureElement=null,this._map=new ve,this._separator=Ne,this._boundProduceCssProperties=(De,ke,Ue,Ke)=>this._produceCssProperties(De,ke,Ue,Ke)}detectMixin(De){const ke=Ce.test(De)||Ee.test(De);return Ce.lastIndex=0,Ee.lastIndex=0,ke}transformStyle(De,ke){let Ue=T(De);return this.transformRules(Ue,ke),Ue}transformRules(De,ke){this._currentTemplate=pe[ke],R(De,Ue=>{this.transformRule(Ue)}),this._currentTemplate=null}transformRule(De){De.cssText=this.transformCssText(De.parsedCssText),':root'===De.selector&&(De.selector=':host > *')}transformCssText(De){return De=De.replace(Ee,this._boundProduceCssProperties),this._consumeCssProperties(De)}_getInitialValueForProperty(De){return this._measureElement||(this._measureElement=document.createElement('meta'),this._measureElement.style.all='initial',document.head.appendChild(this._measureElement)),window.getComputedStyle(this._measureElement).getPropertyValue(De)}_consumeCssProperties(De){for(let ke;ke=Ce.exec(De);){let Ue=ke[0],Ke=ke[1],Xe=ke.index,Ve=Xe+Ue.indexOf('@apply'),je=Xe+Ue.length,Be=De.slice(0,Ve),Ye=De.slice(je),Ge=this._cssTextToMap(Be),qe=this._atApplyToCssProperties(Ke,Ge);De=[Be,qe,Ye].join(''),Ce.lastIndex=Xe+qe.length}return De}_atApplyToCssProperties(De,ke){De=De.replace(Ae,'');let Ue=[],Ke=this._map.get(De);if(Ke||(this._map.set(De,{}),Ke=this._map.get(De)),Ke){this._currentTemplate&&(Ke.dependants[this._currentTemplate.name]=this._currentTemplate);let Xe,Ve,je;for(Xe in Ke.properties)je=ke&&ke[Xe],Ve=[Xe,': var(',De,Ne,Xe],je&&Ve.push(',',je),Ve.push(')'),Ue.push(Ve.join(''))}return Ue.join('; ')}_replaceInitialOrInherit(De,ke){let Ue=Te.exec(ke);return Ue&&(Ue[1]?ke=Re._getInitialValueForProperty(De):ke='apply-shim-inherit'),ke}_cssTextToMap(De){let ke=De.split(';'),Ue,Ke,Xe={};for(let je,Be,Ve=0;Ve<ke.length;Ve++)je=ke[Ve],je&&(Be=je.split(':'),1<Be.length&&(Ue=Be[0].trim(),Ke=this._replaceInitialOrInherit(Ue,Be.slice(1).join(':')),Xe[Ue]=Ke));return Xe}_invalidateMixinEntry(De){for(let ke in De.dependants)this._currentTemplate&&ke===this._currentTemplate.name||me.invalidate(ke)}_produceCssProperties(De,ke,Ue,Ke){if(Ue&&w(Ue,(Qe,Ze)=>{Ze&&this._map.get(Ze)&&(Ke='@apply '+Ze+';')}),!Ke)return De;let Xe=this._consumeCssProperties(Ke),Ve=De.slice(0,De.indexOf('--')),je=this._cssTextToMap(Xe),Be=je,Ye=this._map.get(ke),Ge=Ye&&Ye.properties;Ge?Be=Object.assign(Object.create(Ge),je):this._map.set(ke,Be);let We,ze,qe=[],$e=!1;for(We in Be)ze=je[We],void 0==ze&&(ze='initial'),Ge&&!(We in Ge)&&($e=!0),qe.push(ke+Ne+We+': '+ze);return $e&&this._invalidateMixinEntry(Ye),Ye&&(Ye.properties=Be),Ue&&(Ve=De+';'+Ve),Ve+qe.join('; ')+';'}}let Pe=new Re;window.ApplyShim=Pe;let Ie=function(){};if(!j){let De=Ve=>{return Ve.classList&&!Ve.classList.contains(ie.SCOPE_NAME)||Ve instanceof SVGElement&&(!Ve.hasAttribute('class')||0>Ve.getAttribute('class').indexOf(ie.SCOPE_NAME))},ke=Ve=>{for(let je=0;je<Ve.length;je++){let Be=Ve[je];if(Be.target!==document.documentElement&&Be.target!==document.head){for(let Ye=0;Ye<Be.addedNodes.length;Ye++){let Ge=Be.addedNodes[Ye];if(De(Ge)){let qe=Ge.getRootNode();if(qe.nodeType===Node.DOCUMENT_FRAGMENT_NODE){let We=qe.host;if(We){let ze=We.is||We.localName;ie.dom(Ge,ze)}}}}for(let Ye=0;Ye<Be.removedNodes.length;Ye++){let Ge=Be.removedNodes[Ye];if(Ge.nodeType===Node.ELEMENT_NODE){let qe;if(Ge.classList?qe=Array.from(Ge.classList):Ge.hasAttribute('class')&&(qe=Ge.getAttribute('class').split(/\s+/)),void 0!=qe){let We=qe.indexOf(ie.SCOPE_NAME);if(0<=We){let ze=qe[We+1];ze&&ie.dom(Ge,ze,!0)}}}}}}},Ue=new MutationObserver(ke),Ke=Ve=>{Ue.observe(Ve,{childList:!0,subtree:!0})},Xe=window.customElements&&!window.customElements.flush;if(Xe)Ke(document);else{let Ve=()=>{Ke(document.body)};window.HTMLImports?window.HTMLImports.whenReady(Ve):requestAnimationFrame(function(){if('loading'===document.readyState){let je=function(){Ve(),document.removeEventListener('readystatechange',je)};document.addEventListener('readystatechange',je)}else Ve()})}Ie=function(){ke(Ue.takeRecords())}}let Oe=new class{constructor(ke=100){this.cache={},this.typeMax=ke}_validate(ke,Ue,Ke){for(let Xe=0;Xe<Ke.length;Xe++){let Ve=Ke[Xe];if(ke.properties[Ve]!==Ue[Ve])return!1}return!0}store(ke,Ue,Ke,Xe){let Ve=this.cache[ke]||[];Ve.push({properties:Ue,styleElement:Ke,scopeSelector:Xe}),Ve.length>this.typeMax&&Ve.shift(),this.cache[ke]=Ve}fetch(ke,Ue,Ke){let Xe=this.cache[ke];if(Xe)for(let Ve=Xe.length-1;0<=Ve;Ve--){let je=Xe[Ve];if(this._validate(je,Ue,Ke))return je}}};class Me{constructor(){this._scopeCounter={},this._documentOwner=document.documentElement,this._documentOwnerStyleInfo=me.set(document.documentElement,new me({rules:[]})),this._elementsHaveApplied=!1}get nativeShadow(){return j}get nativeCss(){return B}get nativeCssApply(){return Y}flush(){Ie()}_generateScopeSelector(De){let ke=this._scopeCounter[De]=(this._scopeCounter[De]||0)+1;return`${De}-${ke}`}getStyleAst(De){return T(De)}styleAstToString(De){return A(De)}_gatherStyles(De){let ke=De.content.querySelectorAll('style'),Ue=[];for(let Ke=0;Ke<ke.length;Ke++){let Xe=ke[Ke];Ue.push(Xe.textContent),Xe.parentNode.removeChild(Xe)}return Ue.join('').trim()}_getCssBuild(De){let ke=De.content.querySelector('style');return ke?ke.getAttribute('css-build')||'':''}prepareTemplate(De,ke,Ue){if(!De._prepared){De._prepared=!0,De.name=ke,De.extends=Ue,pe[ke]=De;let Ke=this._getCssBuild(De),Xe=this._gatherStyles(De),Ve={is:ke,extends:Ue,__cssBuild:Ke};this.nativeShadow||ie.dom(De.content,ke);let je=Pe.detectMixin(Xe),Be=e(Xe);je&&this.nativeCss&&!this.nativeCssApply&&Pe.transformRules(Be,ke),De._styleAst=Be;let Ye=[];if(this.nativeCss||(Ye=he.decorateStyles(De._styleAst,Ve)),!Ye.length||this.nativeCss){let Ge=this.nativeShadow?De.content:null,qe=ge[ke],We=this._generateStaticStyle(Ve,De._styleAst,Ge,qe);De._style=We}De._ownPropertyNames=Ye}}_generateStaticStyle(De,ke,Ue,Ke){let Xe=ie.elementStyles(De,ke);if(Xe.length)return P(Xe,De.is,Ue,Ke)}_prepareHost(De){let Ue,ke=De.getAttribute('is')||De.localName;ke!==De.localName&&(Ue=De.localName);let Ve,je,Be,Ke=ge[ke],Xe=pe[ke];return Xe&&(Ve=Xe._styleAst,je=Xe._ownPropertyNames,Be=Xe._cssBuild),me.set(De,new me(Ve,Ke,je,ke,Ue,Be))}applyStyle(De,ke){let Ue=De.getAttribute('is')||De.localName,Ke=me.get(De),Xe=!!Ke;if(Ke||(Ke=this._prepareHost(De)),this._isRootOwner(De)||(this._elementsHaveApplied=!0),window.CustomStyle){let Ve=window.CustomStyle;if(Ve._documentDirty){if(Ve.findStyles(),this.nativeCss?!this.nativeCssApply&&Ve._revalidateApplyShim():this._updateProperties(this._documentOwner,this._documentOwnerStyleInfo),Ve.applyStyles(),!this._elementsHaveApplied)return;if(!this.nativeCss&&(this.updateStyles(),Xe))return}}if(ke&&(Ke.overrideStyleProperties=Ke.overrideStyleProperties||{},Object.assign(Ke.overrideStyleProperties,ke)),this.nativeCss){Ke.overrideStyleProperties&&this._updateNativeProperties(De,Ke.overrideStyleProperties);let Ve=pe[Ue];if(!Ve&&!this._isRootOwner(De))return;if(Ve&&Ve._applyShimInvalid&&Ve._style){if(Ve._validating||(Pe.transformRules(Ve._styleAst,Ue),Ve._style.textContent=ie.elementStyles(De,Ke.styleRules),me.startValidating(Ue)),this.nativeShadow){let je=De.shadowRoot;if(je){let Be=je.querySelector('style');Be.textContent=ie.elementStyles(De,Ke.styleRules)}}Ke.styleRules=Ve._styleAst}}else this._updateProperties(De,Ke),Ke.ownStylePropertyNames&&Ke.ownStylePropertyNames.length&&this._applyStyleProperties(De,Ke);if(Xe){let Ve=this._isRootOwner(De)?De:De.shadowRoot;Ve&&this._applyToDescendants(Ve)}}_applyToDescendants(De){let ke=De.children;for(let Ke,Ue=0;Ue<ke.length;Ue++)Ke=ke[Ue],Ke.shadowRoot&&this.applyStyle(Ke),this._applyToDescendants(Ke)}_styleOwnerForNode(De){let ke=De.getRootNode(),Ue=ke.host;return Ue?me.get(Ue)?Ue:this._styleOwnerForNode(Ue):this._documentOwner}_isRootOwner(De){return De===this._documentOwner}_applyStyleProperties(De,ke){let Ue=De.getAttribute('is')||De.localName,Ke=Oe.fetch(Ue,ke.styleProperties,ke.ownStylePropertyNames),Xe=Ke&&Ke.scopeSelector,Ve=Ke?Ke.styleElement:null,je=ke.scopeSelector;ke.scopeSelector=Xe||this._generateScopeSelector(Ue);let Be=he.applyElementStyle(De,ke.styleProperties,ke.scopeSelector,Ve);return this.nativeShadow||he.applyElementScopeSelector(De,ke.scopeSelector,je),Ke||Oe.store(Ue,ke.styleProperties,Be,ke.scopeSelector),Be}_updateProperties(De,ke){let Ue=this._styleOwnerForNode(De),Ke=me.get(Ue),Xe=Ke.styleProperties,Ve=Object.create(Xe||null),je=he.hostAndRootPropertiesForScope(De,ke.styleRules),Be=he.propertyDataFromStyles(Ke.styleRules,De),Ye=Be.properties;Object.assign(Ve,je.hostProps,Ye,je.rootProps),this._mixinOverrideStyles(Ve,ke.overrideStyleProperties),he.reify(Ve),ke.styleProperties=Ve}_mixinOverrideStyles(De,ke){for(let Ue in ke){let Ke=ke[Ue];(Ke||0===Ke)&&(De[Ue]=Ke)}}_updateNativeProperties(De,ke){for(let Ue in ke)null===Ue?De.style.removeProperty(Ue):De.style.setProperty(Ue,ke[Ue])}updateStyles(De){this.applyStyle(this._documentOwner,De)}_transformCustomStyleForDocument(De){let ke=T(De);R(ke,Ue=>{j?ie.normalizeRootSelector(Ue):ie.documentRule(Ue),this.nativeCss&&!this.nativeCssApply&&Pe.transformRule(Ue)}),this.nativeCss?De.textContent=A(ke):this._documentOwnerStyleInfo.styleRules.rules.push(ke)}_revalidateApplyShim(De){if(this.nativeCss&&!this.nativeCssApply){let ke=T(De);Pe.transformRules(ke),De.textContent=A(ke)}}_applyCustomStyleToDocument(De){this.nativeCss||he.applyCustomStyle(De,this._documentOwnerStyleInfo.styleProperties)}getComputedStyleValue(De,ke){let Ue;if(!this.nativeCss){let Ke=me.get(De)||me.get(this._styleOwnerForNode(De));Ue=Ke.styleProperties[ke]}return Ue=Ue||window.getComputedStyle(De).getPropertyValue(ke),Ue.trim()}setElementClass(De,ke){let Ue=De.getRootNode(),Ke=ke?ke.split(/\s/):[],Xe=Ue.host&&Ue.host.localName;if(!Xe){var Ve=De.getAttribute('class');if(Ve){let je=Ve.split(/\s/);for(let Be=0;Be<je.length;Be++)if(je[Be]===ie.SCOPE_NAME){Xe=je[Be+1];break}}}if(Xe&&Ke.push(ie.SCOPE_NAME,Xe),!this.nativeCss){let je=me.get(De);je&&je.scopeSelector&&Ke.push(he.XSCOPE_NAME,je.scopeSelector)}L(De,Ke.join(' '))}_styleInfoForNode(De){return me.get(De)}}window.ShadyCSS=new Me;let be=window.ShadyCSS,we=!1,Le=[],He=null;class Fe extends HTMLElement{static get _customStyles(){return Le}static get processHook(){return He}static set processHook(De){He=De}static get _documentDirty(){return we}static findStyles(){for(let De=0;De<Le.length;De++){let ke=Le[De];if(!ke._style){let Ue=ke.querySelector('style');if(!Ue)continue;if(Ue.__appliedElement)for(let Ke=0;Ke<Ue.attributes.length;Ke++){let Xe=Ue.attributes[Ke];Ue.__appliedElement.setAttribute(Xe.name,Xe.value)}ke._style=Ue.__appliedElement||Ue,He&&He(ke._style),be._transformCustomStyleForDocument(ke._style)}}}static _revalidateApplyShim(){for(let De=0;De<Le.length;De++){let ke=Le[De];ke._style&&be._revalidateApplyShim(ke._style)}}static applyStyles(){for(let De=0;De<Le.length;De++){let ke=Le[De];ke._style&&be._applyCustomStyleToDocument(ke._style)}we=!1}constructor(){super(),Le.push(this),F()}}window.CustomStyle=Fe,window.customElements.define('custom-style',Fe)})();
//# sourceMappingURL=shadycss.min.js.map
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope) {

  'use strict';

  window.CustomElements = {
    takeRecords: function() {
      if (customElements.flush) {
        customElements.flush();
      }
    }
  }

  HTMLImports.whenReady(function() {
    requestAnimationFrame(function() {
      window.dispatchEvent(new CustomEvent('WebComponentsReady'));
    });
  });

})(window.WebComponents);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope) {

  'use strict';

  // polyfill performance.now

  // Note: old Safari has performance, but not now().
  if (!(window.performance && window.performance.now)) {
    var start = Date.now();
    // only at millisecond precision
    window.performance = {now: function(){ return Date.now() - start; }};
  }

  // polyfill for requestAnimationFrame

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (function() {
      var nativeRaf = window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame;

      return nativeRaf ?
        function(callback) {
          return nativeRaf(function() {
            callback(performance.now());
          });
        } :
        function( callback ){
          return window.setTimeout(callback, 1000 / 60);
        };
    })();
  }

  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = (function() {
      return  window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        function(id) {
          clearTimeout(id);
        };
    })();
  }

  // defaultPrevented is broken in IE.
  // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called
  var workingDefaultPrevented = (function() {
    var e = document.createEvent('Event');
    e.initEvent('foo', true, true);
    e.preventDefault();
    return e.defaultPrevented;
  })();

  if (!workingDefaultPrevented) {
    var origPreventDefault = Event.prototype.preventDefault;
    Event.prototype.preventDefault = function() {
      if (!this.cancelable) {
        return;
      }

      origPreventDefault.call(this);

      Object.defineProperty(this, 'defaultPrevented', {
        get: function() {
          return true;
        },
        configurable: true
      });
    };
  }

  var isIE = /Trident/.test(navigator.userAgent);

  // CustomEvent constructor shim
  if (!window.CustomEvent || isIE && (typeof window.CustomEvent !== 'function')) {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent('CustomEvent');
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }

  // Event constructor shim
  if (!window.Event || isIE && (typeof window.Event !== 'function')) {
    var origEvent = window.Event;
    window.Event = function(inType, params) {
      params = params || {};
      var e = document.createEvent('Event');
      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
      return e;
    };
    if (origEvent) {
      for (var i in origEvent) {
        window.Event[i] = origEvent[i];
      }
    }
    window.Event.prototype = origEvent.prototype;
  }

  if (!window.MouseEvent || isIE && (typeof window.MouseEvent !== 'function')) {
    var origMouseEvent = window.MouseEvent;
    window.MouseEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent('MouseEvent');
      e.initMouseEvent(inType,
        Boolean(params.bubbles), Boolean(params.cancelable),
        params.view || window, params.detail,
        params.screenX, params.screenY, params.clientX, params.clientY,
        params.ctrlKey, params.altKey, params.shiftKey, params.metaKey,
        params.button, params.relatedTarget);
      return e;
    };
    if (origMouseEvent) {
      for (var i in origMouseEvent) {
        window.MouseEvent[i] = origMouseEvent[i];
      }
    }
    window.MouseEvent.prototype = origMouseEvent.prototype;
  }

})(window.WebComponents);
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope) {

  // It's desireable to provide a default stylesheet
  // that's convenient for styling unresolved elements, but
  // it's cumbersome to have to include this manually in every page.
  // It would make sense to put inside some HTMLImport but
  // the HTMLImports polyfill does not allow loading of stylesheets
  // that block rendering. Therefore this injection is tolerated here.
  //
  // NOTE: position: relative fixes IE's failure to inherit opacity
  // when a child is not statically positioned.
  var style = document.createElement('style');
  style.textContent = ''
      + 'body {'
      + 'transition: opacity ease-in 0.2s;'
      + ' } \n'
      + 'body[unresolved] {'
      + 'opacity: 0; display: block; overflow: hidden; position: relative;'
      + ' } \n'
      ;
  var head = document.querySelector('head');
  head.insertBefore(style, head.firstChild);

})(window.WebComponents);